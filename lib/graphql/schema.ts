//
// ‚ùå WARNING: This file is autogenerated.
// üëâ Please use `npm run schema:generate`
//

export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  DateTime: { input: any; output: any; }
  JSON: { input: any; output: any; }
  JSONObject: { input: any; output: any; }
};

/** The bank account of the current user */
export type Account = {
  __typename?: 'Account';
  availableBalance: Scalars['Int']['output'];
  balance: Scalars['Int']['output'];
  bic: Scalars['String']['output'];
  canCreateOverdraft: Scalars['Boolean']['output'];
  card?: Maybe<Card>;
  cardHolderRepresentation?: Maybe<Scalars['String']['output']>;
  cardHolderRepresentations: Array<Scalars['String']['output']>;
  cards: Array<Card>;
  createdAt: Scalars['DateTime']['output'];
  declarationPdfUrl?: Maybe<Scalars['String']['output']>;
  declarationStats: DeclarationStats;
  declarations: Array<Declaration>;
  freeTopUpCreated: Scalars['Boolean']['output'];
  hasPendingCardFraudCase: Scalars['Boolean']['output'];
  iban: Scalars['String']['output'];
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['Float']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** Overdraft Application - only available for Kontist Application */
  overdraft?: Maybe<Overdraft>;
  pendingTransactionVerification: PendingTransactionVerification;
  publicId: Scalars['ID']['output'];
  /** Retrieve account balance from Solaris */
  solarisBalance: SolarisAccountBalance;
  /** Different information about account balances, e.g. taxes, VAT, ... */
  stats: AccountStats;
  /** Individual tax-related settings per year */
  taxYearSettings: Array<TaxYearSetting>;
  transaction?: Maybe<RawTransactionProjection>;
  transactionFilterPresets: Array<FilterPreset>;
  transactions: TransactionsConnection;
  transactionsCSV: Scalars['String']['output'];
  transfer?: Maybe<Transfer>;
  /** A list of iban/name combinations based on existing user's transactions, provided to assist users when creating new transfers */
  transferSuggestions?: Maybe<Array<TransferSuggestion>>;
  transfers: TransfersConnection;
  vatDeclarationSubmissions: Array<DeclarationSubmission>;
  /** Account vat-related settings */
  vatYearSettings: Array<VatYearSetting>;
};


/** The bank account of the current user */
export type AccountCardArgs = {
  filter?: InputMaybe<CardFilter>;
};


/** The bank account of the current user */
export type AccountDeclarationPdfUrlArgs = {
  id: Scalars['Int']['input'];
};


/** The bank account of the current user */
export type AccountDeclarationStatsArgs = {
  period: Scalars['String']['input'];
  year: Scalars['Int']['input'];
};


/** The bank account of the current user */
export type AccountDeclarationsArgs = {
  type: DeclarationType;
};


/** The bank account of the current user */
export type AccountTransactionArgs = {
  id: Scalars['ID']['input'];
};


/** The bank account of the current user */
export type AccountTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<TransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  preset?: InputMaybe<FilterPresetInput>;
  publicId?: InputMaybe<Scalars['String']['input']>;
};


/** The bank account of the current user */
export type AccountTransactionsCsvArgs = {
  from?: InputMaybe<Scalars['DateTime']['input']>;
  to?: InputMaybe<Scalars['DateTime']['input']>;
};


/** The bank account of the current user */
export type AccountTransferArgs = {
  id: Scalars['ID']['input'];
  type: TransferType;
};


/** The bank account of the current user */
export type AccountTransfersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  type: TransferType;
  where?: InputMaybe<TransfersConnectionFilter>;
};


/** The bank account of the current user */
export type AccountVatDeclarationSubmissionsArgs = {
  period: Scalars['String']['input'];
  year: Scalars['Int']['input'];
};


/** The bank account of the current user */
export type AccountVatYearSettingsArgs = {
  year?: InputMaybe<Scalars['Int']['input']>;
};

export type AccountBalance = {
  __typename?: 'AccountBalance';
  currency?: Maybe<Scalars['String']['output']>;
  unit?: Maybe<Scalars['String']['output']>;
  value: Scalars['Float']['output'];
};

export type AccountInsight = {
  __typename?: 'AccountInsight';
  expense: Insight;
  income: Insight;
  period: Period;
  profitAndLoss: Insight;
};

export enum AccountOpeningRequestStatus {
  Completed = 'COMPLETED',
  Initiated = 'INITIATED',
  InProgress = 'IN_PROGRESS',
  Rejected = 'REJECTED'
}

export enum AccountState {
  Blocked = 'BLOCKED',
  Free = 'FREE',
  FreeOld = 'FREE_OLD',
  Premium = 'PREMIUM',
  PremiumOld = 'PREMIUM_OLD',
  Trial = 'TRIAL'
}

export type AccountStats = {
  __typename?: 'AccountStats';
  /** The amount that is currently available on the bank account */
  accountBalance: Scalars['Int']['output'];
  /** The amount that can be spent plus the amount from uknown */
  main: Scalars['Int']['output'];
  /** The amount of tax that is owed in the current year */
  taxCurrentYearAmount: Scalars['Int']['output'];
  /** The difference between taxTotal and accountBalance, if taxTotal > accountbalance */
  taxMissing: Scalars['Int']['output'];
  /** The amount of tax that was owed for all past years combined */
  taxPastYearsAmount?: Maybe<Scalars['Int']['output']>;
  /** The amount of tax that is owed (current + last years) */
  taxTotal: Scalars['Int']['output'];
  /** The amount that is not categorized */
  unknown: Scalars['Int']['output'];
  /** The amount of VAT that is owed in the current year */
  vatAmount: Scalars['Int']['output'];
  /** The difference between vatTotal and accountBalance, if vatTotal > accountBalance */
  vatMissing: Scalars['Int']['output'];
  /** The amount of VAT that is owed (current + last years) */
  vatTotal: Scalars['Int']['output'];
  /** The amount that can be spent after VAT and taxes calculation */
  yours: Scalars['Int']['output'];
};

export enum ActionReason {
  CarUsage = 'CAR_USAGE',
  ElectronicServices = 'ELECTRONIC_SERVICES',
  ExternalBankAccount = 'EXTERNAL_BANK_ACCOUNT',
  IncomingAmountWrong = 'INCOMING_AMOUNT_WRONG',
  InvalidReceipt = 'INVALID_RECEIPT',
  InvoiceAbove_250 = 'INVOICE_ABOVE_250',
  InvoiceBelow_250 = 'INVOICE_BELOW_250',
  InvoiceRequired = 'INVOICE_REQUIRED',
  MissingTaxExemptSales = 'MISSING_TAX_EXEMPT_SALES',
  NoHospitalityReceipt = 'NO_HOSPITALITY_RECEIPT',
  NoReducedTax = 'NO_REDUCED_TAX',
  ObligedTaxes = 'OBLIGED_TAXES',
  OutgoingAmountWrong = 'OUTGOING_AMOUNT_WRONG',
  ReverseChargeInformation = 'REVERSE_CHARGE_INFORMATION',
  ReverseChargeMissing = 'REVERSE_CHARGE_MISSING',
  SmallBusinessMissing = 'SMALL_BUSINESS_MISSING',
  SmallBusinessVat = 'SMALL_BUSINESS_VAT',
  UnclearExpense = 'UNCLEAR_EXPENSE',
  VatIdMissing = 'VAT_ID_MISSING',
  WrongOutgoingInvoice = 'WRONG_OUTGOING_INVOICE',
  WrongTaxrateAncillaryService = 'WRONG_TAXRATE_ANCILLARY_SERVICE'
}

export type Address = {
  __typename?: 'Address';
  city: Scalars['String']['output'];
  country: Scalars['String']['output'];
  postCode: Scalars['String']['output'];
  street: Scalars['String']['output'];
};

export type AddressInput = {
  city: Scalars['String']['input'];
  country: Scalars['String']['input'];
  postCode: Scalars['String']['input'];
  streetName: Scalars['String']['input'];
  streetNumber: Scalars['String']['input'];
};

export enum AnswerType {
  TextAndFiles = 'TEXT_AND_FILES',
  TextOnly = 'TEXT_ONLY'
}

export type Asset = {
  __typename?: 'Asset';
  assetableId: Scalars['ID']['output'];
  filetype: Scalars['String']['output'];
  fullsize: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  path: Scalars['String']['output'];
  thumbnail: Scalars['String']['output'];
};

export enum AssetType {
  Immovable = 'IMMOVABLE',
  Intangible = 'INTANGIBLE',
  MovableMotorVehicles = 'MOVABLE_MOTOR_VEHICLES',
  MovableOfficeEquipment = 'MOVABLE_OFFICE_EQUIPMENT',
  MovableOthers = 'MOVABLE_OTHERS'
}

export type AttributionData = {
  irclickid?: InputMaybe<Scalars['String']['input']>;
  /** Platform used for signup */
  platform?: InputMaybe<Platform>;
  preselected_plan?: InputMaybe<Scalars['String']['input']>;
  trackingId?: InputMaybe<Scalars['String']['input']>;
  utm_source?: InputMaybe<Scalars['String']['input']>;
};

export type AuthorizeChangeRequestResponse = {
  __typename?: 'AuthorizeChangeRequestResponse';
  changeRequestId?: Maybe<Scalars['String']['output']>;
  stringToSign: Scalars['String']['output'];
};

export type AuthorizeThroughDeviceSigningOrMobileNumberResponse = {
  __typename?: 'AuthorizeThroughDeviceSigningOrMobileNumberResponse';
  changeRequestId: Scalars['String']['output'];
  stringToSign?: Maybe<Scalars['String']['output']>;
};

export type AvailableStatements = {
  __typename?: 'AvailableStatements';
  months: Array<Scalars['Int']['output']>;
  year: Scalars['Int']['output'];
};

export type BwaSummary = {
  __typename?: 'BWASummary';
  /** Expenses amount in cents */
  expenses: Scalars['Int']['output'];
  /** Income amount in cents */
  income: Scalars['Int']['output'];
  /** NetIncome amount in cents */
  netIncome: Scalars['Int']['output'];
  /** Withdrawals and deposits amount in cents */
  withdrawalsAndDeposits122: Scalars['Int']['output'];
  /** Withdrawals and deposits amount in cents */
  withdrawalsAndDeposits123: Scalars['Int']['output'];
};

export type Banner = {
  __typename?: 'Banner';
  dismissedAt?: Maybe<Scalars['DateTime']['output']>;
  isVisible: Scalars['Boolean']['output'];
  name: BannerName;
};

export enum BannerName {
  BizTaxTrial = 'BIZ_TAX_TRIAL',
  FriendReferral = 'FRIEND_REFERRAL',
  Overdraft = 'OVERDRAFT',
  ReceiptMatching = 'RECEIPT_MATCHING',
  VatDeclaration = 'VAT_DECLARATION'
}

export enum BaseOperator {
  And = 'AND',
  Or = 'OR'
}

export type BasicAddress = {
  __typename?: 'BasicAddress';
  city: Scalars['String']['output'];
  country: Scalars['String']['output'];
};

export type BatchTransfer = {
  __typename?: 'BatchTransfer';
  id: Scalars['String']['output'];
  status: BatchTransferStatus;
  transfers: Array<SepaTransfer>;
};

export enum BatchTransferStatus {
  Accepted = 'ACCEPTED',
  AuthorizationRequired = 'AUTHORIZATION_REQUIRED',
  ConfirmationRequired = 'CONFIRMATION_REQUIRED',
  Failed = 'FAILED',
  Successful = 'SUCCESSFUL'
}

export type BeneficialOwner = {
  __typename?: 'BeneficialOwner';
  birthDate?: Maybe<Scalars['DateTime']['output']>;
  businessId: Scalars['String']['output'];
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Nationality>;
  fatcaCrsConfirmedAt?: Maybe<Scalars['DateTime']['output']>;
  fatcaRelevant?: Maybe<Scalars['Boolean']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  gender?: Maybe<Gender>;
  id: Scalars['String']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  legalRepresentativeId?: Maybe<Scalars['ID']['output']>;
  nationality?: Maybe<Nationality>;
  postCode?: Maybe<Scalars['String']['output']>;
  street?: Maybe<Scalars['String']['output']>;
  taxCountry?: Maybe<Nationality>;
  taxId?: Maybe<Scalars['String']['output']>;
  votingShare?: Maybe<Scalars['String']['output']>;
};

export type BizTaxBookkeepingConfirmation = {
  __typename?: 'BizTaxBookkeepingConfirmation';
  confirmedAt: Scalars['DateTime']['output'];
  year: Scalars['Int']['output'];
};

export type BizTaxCarUsageEuerRows = {
  __typename?: 'BizTaxCarUsageEuerRows';
  row106: Scalars['Int']['output'];
  row140: Scalars['Int']['output'];
  row142: Scalars['Int']['output'];
  row176: Scalars['Int']['output'];
};

export type BizTaxDeclarationBookkeepingConfirmation = {
  __typename?: 'BizTaxDeclarationBookkeepingConfirmation';
  confirmedAt: Scalars['DateTime']['output'];
  year: Scalars['Int']['output'];
};

export type BizTaxDeclarationCheckResult = {
  __typename?: 'BizTaxDeclarationCheckResult';
  name: Scalars['String']['output'];
  success: Scalars['Boolean']['output'];
};

export type BizTaxDeclarationIsRelevant = {
  __typename?: 'BizTaxDeclarationIsRelevant';
  isRelevant: Scalars['Boolean']['output'];
  year: Scalars['Int']['output'];
};

export type BizTaxDeclarationResultMessage = {
  __typename?: 'BizTaxDeclarationResultMessage';
  fieldIdentifier: Scalars['String']['output'];
  formLineNumber: Scalars['String']['output'];
  text: Scalars['String']['output'];
  type: BizTaxDeclarationResultMessageType;
};

export enum BizTaxDeclarationResultMessageType {
  Notice = 'NOTICE',
  ValidationError = 'VALIDATION_ERROR'
}

export type BizTaxDeclarationSetting = {
  __typename?: 'BizTaxDeclarationSetting';
  bookkeepingConfirmedAt?: Maybe<Scalars['DateTime']['output']>;
  isRelevant: Scalars['Boolean']['output'];
  year: Scalars['Int']['output'];
};

export type BizTaxDeclarationSubmission = {
  __typename?: 'BizTaxDeclarationSubmission';
  calculationSheet?: Maybe<Scalars['String']['output']>;
  isFinal: Scalars['Boolean']['output'];
  isSuccessful: Scalars['Boolean']['output'];
  messages: Array<BizTaxDeclarationResultMessage>;
  pdf?: Maybe<Scalars['String']['output']>;
  submittedAt: Scalars['DateTime']['output'];
  type: BizTaxDeclarationType;
  year: Scalars['Int']['output'];
};

export enum BizTaxDeclarationType {
  Euer = 'EUER',
  TradeTax = 'TRADE_TAX',
  VatAnnual = 'VAT_ANNUAL'
}

export type BizTaxHomeOfficeEuerRows = {
  __typename?: 'BizTaxHomeOfficeEuerRows';
  row172: Scalars['Int']['output'];
  row185: Scalars['Int']['output'];
};

export type BizTaxQuestionnairesEuer = {
  __typename?: 'BizTaxQuestionnairesEuer';
  carUsage: BizTaxCarUsageEuerRows;
  homeOffice: BizTaxHomeOfficeEuerRows;
  travelExpenses: BizTaxTravelExpensesEuerRows;
};

export type BizTaxTravelExpensesEuerRows = {
  __typename?: 'BizTaxTravelExpensesEuerRows';
  row147: Scalars['Int']['output'];
  row171: Scalars['Int']['output'];
  row176: Scalars['Int']['output'];
};

export type BoundDevice = {
  __typename?: 'BoundDevice';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type Business = {
  __typename?: 'Business';
  address?: Maybe<UserBusinessAddress>;
  businessPurpose?: Maybe<Scalars['String']['output']>;
  crsCompanyType?: Maybe<CrsCompanyType>;
  fatcaCrsConfirmedAt?: Maybe<Scalars['DateTime']['output']>;
  fatcaRelevant?: Maybe<Scalars['Boolean']['output']>;
  foundationDate?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['String']['output'];
  legalForm?: Maybe<LegalForm>;
  naceCodeId?: Maybe<Scalars['Float']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  taxConfirmation?: Maybe<TaxConfirmation>;
  taxRegistrationIssuer?: Maybe<Scalars['String']['output']>;
  taxRegistrationNumber?: Maybe<Scalars['String']['output']>;
  termsConditionsSignedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** Business Address of a Kontax User */
export type BusinessAddress = {
  __typename?: 'BusinessAddress';
  city: Scalars['String']['output'];
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  movingDate: Scalars['DateTime']['output'];
  postCode: Scalars['String']['output'];
  street: Scalars['String']['output'];
};

export type BusinessAddressInput = {
  city: Scalars['String']['input'];
  country: Scalars['String']['input'];
  postCode: Scalars['String']['input'];
  streetName: Scalars['String']['input'];
  streetNumber: Scalars['String']['input'];
};

export type BusinessAssetForm = {
  assetClass: Scalars['String']['input'];
  assetType: AssetType;
  depreciationPeriodYears: Scalars['Int']['input'];
  note?: InputMaybe<Scalars['String']['input']>;
  purchaseDate: Scalars['String']['input'];
};

export type BusinessAssetInput = {
  assetClass: Scalars['String']['input'];
  assetType: AssetType;
  depreciationPeriodYears: Scalars['Int']['input'];
};

export type BusinessAssetMetaData = {
  __typename?: 'BusinessAssetMetaData';
  amount: Scalars['Float']['output'];
  transactionDescription?: Maybe<Scalars['String']['output']>;
  transactionName?: Maybe<Scalars['String']['output']>;
  transactionValutaDate?: Maybe<Scalars['DateTime']['output']>;
};

export type BusinessAssetReceipt = {
  __typename?: 'BusinessAssetReceipt';
  filetype: Scalars['String']['output'];
  fullsize: Scalars['String']['output'];
  id: Scalars['String']['output'];
};

export type BusinessAssetResponse = {
  __typename?: 'BusinessAssetResponse';
  amount: Scalars['Float']['output'];
  assetClass: Scalars['String']['output'];
  assetType: AssetType;
  bookValueOnExit?: Maybe<Scalars['Int']['output']>;
  categoryCode: Scalars['String']['output'];
  depreciationPeriodYears: Scalars['Float']['output'];
  depreciations: Array<Depreciation>;
  endAmount?: Maybe<Scalars['Int']['output']>;
  exitAmount?: Maybe<Scalars['Int']['output']>;
  exitDate?: Maybe<Scalars['DateTime']['output']>;
  exitReason?: Maybe<ExitReason>;
  id: Scalars['String']['output'];
  isExitedWithVat?: Maybe<Scalars['Boolean']['output']>;
  metaData?: Maybe<BusinessAssetMetaData>;
  naturallyDepreciated: Scalars['Boolean']['output'];
  note?: Maybe<Scalars['String']['output']>;
  purchaseDate: Scalars['DateTime']['output'];
  receipts: Array<BusinessAssetReceipt>;
};

export type BusinessIdentification = {
  __typename?: 'BusinessIdentification';
  businessId: Scalars['String']['output'];
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  complianceQuestions?: Maybe<Array<ComplianceQuestion>>;
  documentsSubmittedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['String']['output'];
  legalIdentificationMissingInformation?: Maybe<Array<Scalars['String']['output']>>;
  legalIdentificationMissingInformationDetails?: Maybe<Scalars['String']['output']>;
  legalIdentificationStatus: Scalars['String']['output'];
  markedAsReadyAt?: Maybe<Scalars['DateTime']['output']>;
  questionsSubmittedAt?: Maybe<Scalars['DateTime']['output']>;
  requiredDocuments: Array<Scalars['String']['output']>;
  status: Scalars['String']['output'];
};

export type BusinessInput = {
  address?: InputMaybe<UpsertAddressInput>;
  businessPurpose?: InputMaybe<Scalars['String']['input']>;
  crsCompanyType?: InputMaybe<CrsCompanyType>;
  fatcaCrsConfirmedAt?: InputMaybe<Scalars['DateTime']['input']>;
  fatcaRelevant?: InputMaybe<Scalars['Boolean']['input']>;
  foundationDate?: InputMaybe<Scalars['DateTime']['input']>;
  legalForm?: InputMaybe<LegalForm>;
  naceCodeId?: InputMaybe<Scalars['Float']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  taxConfirmation?: InputMaybe<TaxConfirmation>;
  taxRegistrationIssuer?: InputMaybe<Scalars['String']['input']>;
  taxRegistrationNumber?: InputMaybe<Scalars['String']['input']>;
  termsConditionsSignedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Commercial registration provided by Solaris */
export type BusinessResultLegalRepresentative = {
  __typename?: 'BusinessResultLegalRepresentative';
  firstName: Scalars['String']['output'];
  lastName: Scalars['String']['output'];
};

export type BusinessSignupData = {
  __typename?: 'BusinessSignupData';
  address?: Maybe<Address>;
  businessPurpose?: Maybe<Scalars['String']['output']>;
  crsCompanyType?: Maybe<CrsCompanyType>;
  customerVettingStatus?: Maybe<CustomerVettingStatus>;
  fatcaCrsConfirmedAt?: Maybe<Scalars['DateTime']['output']>;
  fatcaRelevant?: Maybe<Scalars['Boolean']['output']>;
  foundationDate?: Maybe<Scalars['DateTime']['output']>;
  legalForm?: Maybe<LegalForm>;
  naceCodeId?: Maybe<Scalars['Float']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  riskClassificationStatus?: Maybe<RiskClassificationStatus>;
  screeningProgress?: Maybe<ScreeningProgress>;
  taxRegistrationIssuer?: Maybe<Scalars['String']['output']>;
  taxRegistrationNumber?: Maybe<Scalars['String']['output']>;
  termsConditionsSignedAt?: Maybe<Scalars['DateTime']['output']>;
};

export enum CrsCompanyType {
  FeNonReporting = 'FE_NON_REPORTING',
  FeReporting = 'FE_REPORTING',
  NfeActive = 'NFE_ACTIVE',
  NfeActiveOther = 'NFE_ACTIVE_OTHER',
  NfePassive = 'NFE_PASSIVE',
  NfePassiveInvestment = 'NFE_PASSIVE_INVESTMENT'
}

export type Card = {
  __typename?: 'Card';
  addedToApplePay: Scalars['Boolean']['output'];
  formattedExpirationDate?: Maybe<Scalars['String']['output']>;
  googlePayTokens: Array<GooglePayCardToken>;
  holder?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  maskedPan?: Maybe<Scalars['String']['output']>;
  newCardOrdered: Scalars['Boolean']['output'];
  pinKey: CardPinKey;
  pinSet: Scalars['Boolean']['output'];
  settings: CardSettings;
  status: CardStatus;
  type: CardType;
};

export enum CardAction {
  Block = 'BLOCK',
  Close = 'CLOSE',
  Unblock = 'UNBLOCK'
}

export type CardFilter = {
  id?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<CardType>;
};

export type CardLimit = {
  __typename?: 'CardLimit';
  maxAmountCents: Scalars['Float']['output'];
  maxTransactions: Scalars['Float']['output'];
};

export type CardLimitInput = {
  maxAmountCents?: InputMaybe<Scalars['Float']['input']>;
  maxTransactions?: InputMaybe<Scalars['Float']['input']>;
};

export type CardLimits = {
  __typename?: 'CardLimits';
  daily: CardLimit;
  monthly: CardLimit;
};

export type CardLimitsInput = {
  daily?: InputMaybe<CardLimitInput>;
  monthly?: InputMaybe<CardLimitInput>;
};

export type CardPinKey = {
  __typename?: 'CardPINKey';
  alg: Scalars['String']['output'];
  e: Scalars['String']['output'];
  kid: Scalars['String']['output'];
  kty: Scalars['String']['output'];
  n: Scalars['String']['output'];
  use: Scalars['String']['output'];
};

export type CardSettings = {
  __typename?: 'CardSettings';
  cardSpendingLimits?: Maybe<CardSpendingLimits>;
};

export type CardSettingsInput = {
  atmLimits?: InputMaybe<CardLimitsInput>;
  purchaseLimits?: InputMaybe<CardLimitsInput>;
};

export type CardSpendingLimits = {
  __typename?: 'CardSpendingLimits';
  atm: CardLimits;
  purchase: CardLimits;
};

export enum CardStatus {
  ActivationBlockedBySolaris = 'ACTIVATION_BLOCKED_BY_SOLARIS',
  Active = 'ACTIVE',
  Blocked = 'BLOCKED',
  BlockedBySolaris = 'BLOCKED_BY_SOLARIS',
  Closed = 'CLOSED',
  ClosedBySolaris = 'CLOSED_BY_SOLARIS',
  Inactive = 'INACTIVE',
  Processing = 'PROCESSING'
}

export enum CardType {
  MastercardBusinessDebit = 'MASTERCARD_BUSINESS_DEBIT',
  VirtualMastercardBusinessDebit = 'VIRTUAL_MASTERCARD_BUSINESS_DEBIT',
  VirtualVisaBusinessDebit = 'VIRTUAL_VISA_BUSINESS_DEBIT',
  VirtualVisaFreelanceDebit = 'VIRTUAL_VISA_FREELANCE_DEBIT',
  VisaBusinessDebit = 'VISA_BUSINESS_DEBIT',
  VisaBusinessDebit_2 = 'VISA_BUSINESS_DEBIT_2'
}

export enum CaseResolution {
  Confirmed = 'CONFIRMED',
  Pending = 'PENDING',
  TimedOut = 'TIMED_OUT',
  Timeout = 'TIMEOUT',
  Whitelisted = 'WHITELISTED'
}

export enum CategorizationType {
  AutomaticKontistMl = 'AUTOMATIC_KONTIST_ML',
  BookkeepingPartner = 'BOOKKEEPING_PARTNER',
  Invoicing = 'INVOICING',
  Kontax = 'KONTAX',
  Script = 'SCRIPT',
  SuggestedByMl = 'SUGGESTED_BY_ML',
  User = 'USER',
  UserOverwrite = 'USER_OVERWRITE'
}

export type CategorizeTransactionForDeclarationResponse = {
  __typename?: 'CategorizeTransactionForDeclarationResponse';
  category?: Maybe<TransactionCategory>;
  categoryCode?: Maybe<Scalars['String']['output']>;
  date?: Maybe<Scalars['String']['output']>;
  vatCategoryCode?: Maybe<Scalars['String']['output']>;
};

export enum CategoryCode {
  Accommodation = 'ACCOMMODATION',
  Advertising = 'ADVERTISING',
  AssetsGreaterThanEur_250 = 'ASSETS_GREATER_THAN_EUR_250',
  AssetsGreaterThanEur_800 = 'ASSETS_GREATER_THAN_EUR_800',
  AssetsLessThanEur_250 = 'ASSETS_LESS_THAN_EUR_250',
  BankFees = 'BANK_FEES',
  Books = 'BOOKS',
  CarCosts = 'CAR_COSTS',
  CarFees = 'CAR_FEES',
  ConstructionRevenue = 'CONSTRUCTION_REVENUE',
  CoronaHelp = 'CORONA_HELP',
  DailyAllowance = 'DAILY_ALLOWANCE',
  Deposit = 'DEPOSIT',
  DownPayment = 'DOWN_PAYMENT',
  Education = 'EDUCATION',
  ElectronicServiceEuB2C = 'ELECTRONIC_SERVICE_EU_B2C',
  ElectronicServiceEuB2CKu = 'ELECTRONIC_SERVICE_EU_B2C_KU',
  Entertainment = 'ENTERTAINMENT',
  ExternalFreelancer = 'EXTERNAL_FREELANCER',
  Fees = 'FEES',
  FreeValueDelivery = 'FREE_VALUE_DELIVERY',
  FreeValueDeliveryPv_19 = 'FREE_VALUE_DELIVERY_PV_19',
  FreeValueService = 'FREE_VALUE_SERVICE',
  Gifts = 'GIFTS',
  Goods = 'GOODS',
  ImportVat = 'IMPORT_VAT',
  IncomeEu = 'INCOME_EU',
  IncomeGermany = 'INCOME_GERMANY',
  IncomeIntl = 'INCOME_INTL',
  IncomeOnlyVat = 'INCOME_ONLY_VAT',
  Insurances = 'INSURANCES',
  InterestsAssets = 'INTERESTS_ASSETS',
  InterestsCarAssets = 'INTERESTS_CAR_ASSETS',
  InterestsOther = 'INTERESTS_OTHER',
  ItCosts = 'IT_COSTS',
  LeasingCar = 'LEASING_CAR',
  LeasingMovables = 'LEASING_MOVABLES',
  LegalTaxConsulting = 'LEGAL_TAX_CONSULTING',
  LimitedDeductibleExpenses = 'LIMITED_DEDUCTIBLE_EXPENSES',
  LimitedNotDeductibleExpenses = 'LIMITED_NOT_DEDUCTIBLE_EXPENSES',
  MaintenanceCosts = 'MAINTENANCE_COSTS',
  OfficeCosts = 'OFFICE_COSTS',
  OtherExpenses = 'OTHER_EXPENSES',
  OtherUsageAndServiceWithdrawals = 'OTHER_USAGE_AND_SERVICE_WITHDRAWALS',
  Payroll = 'PAYROLL',
  PrivateIn = 'PRIVATE_IN',
  PrivateOut = 'PRIVATE_OUT',
  PrivateWithdrawal = 'PRIVATE_WITHDRAWAL',
  PublicTransport = 'PUBLIC_TRANSPORT',
  Rent = 'RENT',
  RevenueSb = 'REVENUE_SB',
  ShippingCosts = 'SHIPPING_COSTS',
  SoftwareAndLicenses = 'SOFTWARE_AND_LICENSES',
  TaxPayment = 'TAX_PAYMENT',
  TaxRefund = 'TAX_REFUND',
  Telecommunication = 'TELECOMMUNICATION',
  TradeTaxPayment = 'TRADE_TAX_PAYMENT',
  TradeTaxRefund = 'TRADE_TAX_REFUND',
  TravelCosts = 'TRAVEL_COSTS',
  Vat = 'VAT',
  VatOnUnpaidItems = 'VAT_ON_UNPAID_ITEMS',
  VatPayment = 'VAT_PAYMENT',
  VatRefund = 'VAT_REFUND',
  WasteDisposals = 'WASTE_DISPOSALS'
}

export type CategoryGroup = {
  __typename?: 'CategoryGroup';
  amount: Scalars['Int']['output'];
  categoryCode: Scalars['String']['output'];
  categoryCodeTranslation: Scalars['String']['output'];
  transactions: Array<TransactionForAccountingView>;
};

export type ChangeCardPinEncryptedInput = {
  deviceId: Scalars['String']['input'];
  encryptedPin: Scalars['String']['input'];
  keyId: Scalars['String']['input'];
  signature: Scalars['String']['input'];
};

export type ChangeCardPinWithChangeRequestInput = {
  encryptedPin: Scalars['String']['input'];
  keyId: Scalars['String']['input'];
};

export type Client = {
  __typename?: 'Client';
  /** The grant types (i.e. ways to obtain access tokens) allowed for the client */
  grantTypes?: Maybe<Array<GrantType>>;
  id: Scalars['ID']['output'];
  /** The name of the OAuth2 client displayed when users log in */
  name: Scalars['String']['output'];
  /** The URL to redirect to after authentication */
  redirectUri?: Maybe<Scalars['String']['output']>;
  /** The scopes the client has access to, limiting access to the corresponding parts of the API */
  scopes?: Maybe<Array<ScopeType>>;
};

export type CompanyDetails = {
  __typename?: 'CompanyDetails';
  address: SolarisBusinessAddress;
  businessPurpose?: Maybe<Scalars['String']['output']>;
  foundedDate?: Maybe<Scalars['String']['output']>;
  legalForm: Scalars['String']['output'];
  legalRepresentatives: Array<BusinessResultLegalRepresentative>;
  naceCodeId?: Maybe<Scalars['Float']['output']>;
  name: Scalars['String']['output'];
  registrationIssuer: Scalars['String']['output'];
  registrationNumber: Scalars['String']['output'];
};

export type CompanySuggestion = {
  __typename?: 'CompanySuggestion';
  address: BasicAddress;
  legalForm: Scalars['String']['output'];
  name: Scalars['String']['output'];
  registrationIssuer: Scalars['String']['output'];
  registrationNumber: Scalars['String']['output'];
};

export enum CompanyType {
  Ador = 'ADOR',
  Ag = 'AG',
  Agcokg = 'AGCOKG',
  Amt = 'AMT',
  AtAg = 'AT_AG',
  AtAmt = 'AT_AMT',
  AtEg = 'AT_EG',
  AtEv = 'AT_EV',
  AtGbr = 'AT_GBR',
  AtGesmbh = 'AT_GESMBH',
  AtGmbh = 'AT_GMBH',
  AtGmbhCoKg = 'AT_GMBH_CO_KG',
  AtKg = 'AT_KG',
  AtKor = 'AT_KOR',
  AtOhg = 'AT_OHG',
  AtSe = 'AT_SE',
  AtSelfEmployed = 'AT_SELF_EMPLOYED',
  AtSoleProprietorship = 'AT_SOLE_PROPRIETORSHIP',
  AtStiftungen = 'AT_STIFTUNGEN',
  BeSa = 'BE_SA',
  BeSc = 'BE_SC',
  BeSca = 'BE_SCA',
  BeScri = 'BE_SCRI',
  BeScs = 'BE_SCS',
  BeSe = 'BE_SE',
  BeSelfEmployed = 'BE_SELF_EMPLOYED',
  BeSep = 'BE_SEP',
  BeSf = 'BE_SF',
  BeSnc = 'BE_SNC',
  BeSoleProprietorship = 'BE_SOLE_PROPRIETORSHIP',
  BeSprl = 'BE_SPRL',
  BeSprlu = 'BE_SPRLU',
  BgAd = 'BG_AD',
  BgKd = 'BG_KD',
  BgKda = 'BG_KDA',
  BgOod = 'BG_OOD',
  BgSd = 'BG_SD',
  BgSelfEmployed = 'BG_SELF_EMPLOYED',
  BgSoleProprietorship = 'BG_SOLE_PROPRIETORSHIP',
  ChDeAg = 'CH_DE_AG',
  ChDeEg = 'CH_DE_EG',
  ChDeGmbh = 'CH_DE_GMBH',
  ChDeKg = 'CH_DE_KG',
  ChDeKig = 'CH_DE_KIG',
  ChDeKmg = 'CH_DE_KMG',
  ChDeKomag = 'CH_DE_KOMAG',
  ChFrSa = 'CH_FR_SA',
  ChFrSarl = 'CH_FR_SARL',
  ChFrSca = 'CH_FR_SCA',
  ChFrScm = 'CH_FR_SCM',
  ChFrSnc = 'CH_FR_SNC',
  ChFrSs = 'CH_FR_SS',
  ChItSa = 'CH_IT_SA',
  ChItSac = 'CH_IT_SAC',
  ChItSaca = 'CH_IT_SACA',
  ChItSagl = 'CH_IT_SAGL',
  ChItSnc = 'CH_IT_SNC',
  ChItSs = 'CH_IT_SS',
  ChSe = 'CH_SE',
  ChSelfEmployed = 'CH_SELF_EMPLOYED',
  ChSoleProprietorship = 'CH_SOLE_PROPRIETORSHIP',
  CzAs = 'CZ_AS',
  CzDruzstvo = 'CZ_DRUZSTVO',
  CzFyzickaOsoba = 'CZ_FYZICKA_OSOBA',
  CzKs = 'CZ_KS',
  CzSelfEmployed = 'CZ_SELF_EMPLOYED',
  CzSoleProprietorship = 'CZ_SOLE_PROPRIETORSHIP',
  CzSro = 'CZ_SRO',
  CzVos = 'CZ_VOS',
  Eg = 'EG',
  Einzelunternehmer = 'EINZELUNTERNEHMER',
  Ek = 'EK',
  EsSa = 'ES_SA',
  EsSas = 'ES_SAS',
  EsSau = 'ES_SAU',
  EsSc = 'ES_SC',
  EsSca = 'ES_SCA',
  EsScop = 'ES_SCOP',
  EsSe = 'ES_SE',
  EsSelfEmployed = 'ES_SELF_EMPLOYED',
  EsSlne = 'ES_SLNE',
  EsSlu = 'ES_SLU',
  EsSoleProprietorship = 'ES_SOLE_PROPRIETORSHIP',
  EsSpro = 'ES_SPRO',
  EsSrc = 'ES_SRC',
  EsSrl = 'ES_SRL',
  Ev = 'EV',
  EK = 'E_K',
  ForeignCorporation = 'FOREIGN_CORPORATION',
  Freiberufler = 'FREIBERUFLER',
  FrAe = 'FR_AE',
  FrEi = 'FR_EI',
  FrEurl = 'FR_EURL',
  FrSa = 'FR_SA',
  FrSarl = 'FR_SARL',
  FrSas = 'FR_SAS',
  FrSc = 'FR_SC',
  FrSca = 'FR_SCA',
  FrScop = 'FR_SCOP',
  FrScs = 'FR_SCS',
  FrSe = 'FR_SE',
  FrSelarl = 'FR_SELARL',
  FrSelfEmployed = 'FR_SELF_EMPLOYED',
  FrSnc = 'FR_SNC',
  FrSoleProprietorship = 'FR_SOLE_PROPRIETORSHIP',
  Gbr = 'GBR',
  GbCops = 'GB_COPS',
  GbLp = 'GB_LP',
  GbLtd = 'GB_LTD',
  GbPartnership = 'GB_PARTNERSHIP',
  GbPlc = 'GB_PLC',
  GbPrcu = 'GB_PRCU',
  GbPucu = 'GB_PUCU',
  GbSe = 'GB_SE',
  GbSelfEmployed = 'GB_SELF_EMPLOYED',
  GbSoleProprietorship = 'GB_SOLE_PROPRIETORSHIP',
  GbUas = 'GB_UAS',
  Gewerbetreibender = 'GEWERBETREIBENDER',
  Gmbh = 'GMBH',
  GmbhCoKg = 'GMBH_CO_KG',
  GmbhIGr = 'GMBH_I_GR',
  GmbhUndCoKg = 'GMBH_UND_CO_KG',
  HrDd = 'HR_DD',
  HrDoo = 'HR_DOO',
  HrJdoo = 'HR_JDOO',
  HrJtd = 'HR_JTD',
  HrKd = 'HR_KD',
  HrOrta = 'HR_ORTA',
  HrSelfEmployed = 'HR_SELF_EMPLOYED',
  HrSoleProprietorship = 'HR_SOLE_PROPRIETORSHIP',
  HuBt = 'HU_BT',
  HuKft = 'HU_KFT',
  HuKkt = 'HU_KKT',
  HuNyrt = 'HU_NYRT',
  HuOrta = 'HU_ORTA',
  HuSelfEmployed = 'HU_SELF_EMPLOYED',
  HuSoleProprietorship = 'HU_SOLE_PROPRIETORSHIP',
  ItSapa = 'IT_SAPA',
  ItSas = 'IT_SAS',
  ItScarl = 'IT_SCARL',
  ItScop = 'IT_SCOP',
  ItScpa = 'IT_SCPA',
  ItSe = 'IT_SE',
  ItSelfEmployed = 'IT_SELF_EMPLOYED',
  ItSnc = 'IT_SNC',
  ItSoleProprietorship = 'IT_SOLE_PROPRIETORSHIP',
  ItSpa = 'IT_SPA',
  ItSrl = 'IT_SRL',
  ItSs = 'IT_SS',
  Kdor = 'KDOR',
  Kg = 'KG',
  Kgaa = 'KGAA',
  Limited = 'LIMITED',
  Ltd = 'LTD',
  LuAsbl = 'LU_ASBL',
  LuFon = 'LU_FON',
  LuSa = 'LU_SA',
  LuSarl = 'LU_SARL',
  LuSarls = 'LU_SARLS',
  LuSc = 'LU_SC',
  LuSca = 'LU_SCA',
  LuScop = 'LU_SCOP',
  LuScs = 'LU_SCS',
  LuScsp = 'LU_SCSP',
  LuSe = 'LU_SE',
  LuSeca = 'LU_SECA',
  LuSelfEmployed = 'LU_SELF_EMPLOYED',
  LuSnc = 'LU_SNC',
  LuSoleProprietorship = 'LU_SOLE_PROPRIETORSHIP',
  LuSp = 'LU_SP',
  Municipality = 'MUNICIPALITY',
  MunicipalCompany = 'MUNICIPAL_COMPANY',
  Nev = 'NEV',
  NlBv = 'NL_BV',
  NlCopv = 'NL_COPV',
  NlCv = 'NL_CV',
  NlCvoa = 'NL_CVOA',
  NlMts = 'NL_MTS',
  NlNv = 'NL_NV',
  NlSe = 'NL_SE',
  NlSelfEmployed = 'NL_SELF_EMPLOYED',
  NlSoleProprietorship = 'NL_SOLE_PROPRIETORSHIP',
  NlSticht = 'NL_STICHT',
  NlVereniging = 'NL_VERENIGING',
  NlVof = 'NL_VOF',
  None = 'NONE',
  Ohg = 'OHG',
  Partg = 'PARTG',
  Partgg = 'PARTGG',
  PlOther = 'PL_OTHER',
  PlSa = 'PL_SA',
  PlSe = 'PL_SE',
  PlSelfEmployed = 'PL_SELF_EMPLOYED',
  PlSka = 'PL_SKA',
  PlSpj = 'PL_SPJ',
  PlSpk = 'PL_SPK',
  PlSpzoo = 'PL_SPZOO',
  PrivatePerson = 'PRIVATE_PERSON',
  PtCop = 'PT_COP',
  PtEirl = 'PT_EIRL',
  PtLda = 'PT_LDA',
  PtSa = 'PT_SA',
  PtSc = 'PT_SC',
  PtSciv = 'PT_SCIV',
  PtSe = 'PT_SE',
  PtSelfEmployed = 'PT_SELF_EMPLOYED',
  PtSnc = 'PT_SNC',
  PtSoleProprietorship = 'PT_SOLE_PROPRIETORSHIP',
  PtSuni = 'PT_SUNI',
  RoSa = 'RO_SA',
  RoSca = 'RO_SCA',
  RoScs = 'RO_SCS',
  RoSelfEmployed = 'RO_SELF_EMPLOYED',
  RoSnc = 'RO_SNC',
  RoSoleProprietorship = 'RO_SOLE_PROPRIETORSHIP',
  RoSrl = 'RO_SRL',
  RsAd = 'RS_AD',
  RsDoo = 'RS_DOO',
  RsKd = 'RS_KD',
  RsOd = 'RS_OD',
  RsSelfEmployed = 'RS_SELF_EMPLOYED',
  RsSoleProprietorship = 'RS_SOLE_PROPRIETORSHIP',
  SavingsBank = 'SAVINGS_BANK',
  Se = 'SE',
  Secokg = 'SECOKG',
  Selbstaendig = 'SELBSTAENDIG',
  SelfEmployed = 'SELF_EMPLOYED',
  SiDd = 'SI_DD',
  SiDno = 'SI_DNO',
  SiDoo = 'SI_DOO',
  SiKd = 'SI_KD',
  SiKdd = 'SI_KDD',
  SiSelfEmployed = 'SI_SELF_EMPLOYED',
  SiSoleProprietorship = 'SI_SOLE_PROPRIETORSHIP',
  SoleProprietorship = 'SOLE_PROPRIETORSHIP',
  Stiftungen = 'STIFTUNGEN',
  TrAdiSir = 'TR_ADI_SIR',
  TrAs = 'TR_AS',
  TrKollSti = 'TR_KOLL_STI',
  TrKomSti = 'TR_KOM_STI',
  TrLs = 'TR_LS',
  TrSelfEmployed = 'TR_SELF_EMPLOYED',
  TrSoleProprietorship = 'TR_SOLE_PROPRIETORSHIP',
  Ug = 'UG',
  UgIGr = 'UG_I_GR'
}

export type ComplianceQuestion = {
  __typename?: 'ComplianceQuestion';
  question: Scalars['String']['output'];
  questionId: Scalars['String']['output'];
};

export type ConfirmChangeRequestArgs = {
  authorizationToken?: InputMaybe<Scalars['String']['input']>;
  changeRequestId: Scalars['String']['input'];
  deviceId: Scalars['String']['input'];
  signature?: InputMaybe<Scalars['String']['input']>;
};

export type ConfirmChangeRequestResponse = {
  __typename?: 'ConfirmChangeRequestResponse';
  success: Scalars['Boolean']['output'];
};

export type ConfirmFraudResponse = {
  __typename?: 'ConfirmFraudResponse';
  id: Scalars['String']['output'];
  resolution: CaseResolution;
};

export type ConfirmationRequest = {
  __typename?: 'ConfirmationRequest';
  confirmationId: Scalars['String']['output'];
  stringToSign?: Maybe<Scalars['String']['output']>;
};

export type ConfirmationRequestOrTransfer = ConfirmationRequest | Transfer;

export type ConfirmationStatus = {
  __typename?: 'ConfirmationStatus';
  status: Scalars['String']['output'];
};

/** User transfer contacts */
export type Contact = {
  __typename?: 'Contact';
  favorite: Scalars['Boolean']['output'];
  iban: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type CreateAssetResponse = {
  __typename?: 'CreateAssetResponse';
  assetId: Scalars['ID']['output'];
  formData: Array<FormDataPair>;
  name?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
};

export type CreateBeneficialOwnerInput = {
  birthDate?: InputMaybe<Scalars['DateTime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Nationality>;
  fatcaCrsConfirmedAt?: InputMaybe<Scalars['DateTime']['input']>;
  fatcaRelevant?: InputMaybe<Scalars['Boolean']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Gender>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  legalRepresentativeId?: InputMaybe<Scalars['String']['input']>;
  nationality?: InputMaybe<Nationality>;
  postCode?: InputMaybe<Scalars['String']['input']>;
  street?: InputMaybe<Scalars['String']['input']>;
  taxCountry?: InputMaybe<Nationality>;
  taxId?: InputMaybe<Scalars['String']['input']>;
  votingShare?: InputMaybe<Scalars['String']['input']>;
};

export type CreateBusinessAddressInput = {
  city: Scalars['String']['input'];
  movingDate: Scalars['DateTime']['input'];
  postCode: Scalars['String']['input'];
  street: Scalars['String']['input'];
};

/** The available fields to create an OAuth2 client */
export type CreateClientInput = {
  /** The grant types (i.e. ways to obtain access tokens) allowed for the client */
  grantTypes: Array<GrantType>;
  /** The name of the OAuth2 client displayed when users log in */
  name: Scalars['String']['input'];
  /** The URL to redirect to after authentication */
  redirectUri?: InputMaybe<Scalars['String']['input']>;
  /** The scopes the client has access to, limiting access to the corresponding parts of the API */
  scopes: Array<ScopeType>;
  /** The OAuth2 client secret */
  secret?: InputMaybe<Scalars['String']['input']>;
};

export type CreateContactArgs = {
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  iban: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type CreateDeclarationApprovalInput = {
  declarationId: Scalars['ID']['input'];
  declarationType: TaxDeclarationType;
  delaySubmission?: InputMaybe<Scalars['Boolean']['input']>;
  jointDeclaration?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CreateDeclarationDeclineInput = {
  declarationId: Scalars['ID']['input'];
  declarationType: TaxDeclarationType;
  reason: Scalars['String']['input'];
};

export type CreateDraftTransactionInput = {
  amount: Scalars['Int']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  paymentDate: Scalars['DateTime']['input'];
};

export type CreateDraftTransactionResponse = {
  __typename?: 'CreateDraftTransactionResponse';
  assetData: CreateAssetResponse;
  id: Scalars['ID']['output'];
};

export type CreateIntraCustomerTransferInput = {
  amount: Scalars['Float']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  fromAccountPublicId: Scalars['String']['input'];
  reference: Scalars['String']['input'];
  toAccountPublicId: Scalars['String']['input'];
};

export type CreateIntraCustomerTransferPayload = {
  __typename?: 'CreateIntraCustomerTransferPayload';
  amount: Scalars['Float']['output'];
  createdAt: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  recipientIban: Scalars['String']['output'];
  reference: Scalars['String']['output'];
};

export type CreateInvoiceLogoResponse = {
  __typename?: 'CreateInvoiceLogoResponse';
  formData: Array<InvoiceLogoFormDataPair>;
  url: Scalars['String']['output'];
};

export type CreateLegalRepresentativeInput = {
  email?: InputMaybe<Scalars['String']['input']>;
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
};

export type CreateReviewResponse = {
  __typename?: 'CreateReviewResponse';
  error?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** The available fields to create a SEPA Transfer */
export type CreateSepaTransferInput = {
  /** The amount of the SEPA Transfer in cents */
  amount: Scalars['Int']['input'];
  /** The end to end ID of the SEPA Transfer */
  e2eId?: InputMaybe<Scalars['String']['input']>;
  /** The IBAN of the SEPA Transfer recipient */
  iban: Scalars['String']['input'];
  /** The personal note of the SEPA Transfer - 250 max characters */
  personalNote?: InputMaybe<Scalars['String']['input']>;
  /** The purpose of the SEPA Transfer - 140 max characters */
  purpose?: InputMaybe<Scalars['String']['input']>;
  /** The name of the SEPA Transfer recipient */
  recipient: Scalars['String']['input'];
};

export type CreateTaxNumberInput = {
  description: Scalars['String']['input'];
  isMainBusinessTaxNumber: Scalars['Boolean']['input'];
  taxNumber: Scalars['String']['input'];
  type: TaxNumberType;
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

export type CreateTransactionSplitsInput = {
  amount: Scalars['Int']['input'];
  category?: InputMaybe<TransactionCategory>;
  categoryCode?: InputMaybe<Scalars['String']['input']>;
  userSelectedBookingDate?: InputMaybe<Scalars['DateTime']['input']>;
  vatCategoryCode?: InputMaybe<Scalars['String']['input']>;
  vatRate?: InputMaybe<VatRate>;
};

/** The available fields to create a transfer */
export type CreateTransferInput = {
  /** The amount of the transfer in cents */
  amount: Scalars['Int']['input'];
  /** The user selected category for the SEPA Transfer */
  category?: InputMaybe<TransactionCategory>;
  /** The end to end ID of the transfer */
  e2eId?: InputMaybe<Scalars['String']['input']>;
  /** The date at which the payment will be executed for Timed Orders or Standing Orders */
  executeAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The IBAN of the transfer recipient */
  iban: Scalars['String']['input'];
  /** The date at which the last payment will be executed for Standing Orders */
  lastExecutionDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** The personal note of the transfer - 250 max characters */
  personalNote?: InputMaybe<Scalars['String']['input']>;
  /** The purpose of the transfer - 140 max characters */
  purpose?: InputMaybe<Scalars['String']['input']>;
  /** The name of the transfer recipient */
  recipient: Scalars['String']['input'];
  /** Unique id of transfer session */
  reference?: InputMaybe<Scalars['String']['input']>;
  /** The reoccurrence type of the payments for Standing Orders */
  reoccurrence?: InputMaybe<StandingOrderReoccurrenceType>;
  /** The type of transfer created by user */
  type?: InputMaybe<TransferType>;
  /** When a transaction corresponds to a tax or vat payment, the user may specify at which date it should be considered booked */
  userSelectedBookingDate?: InputMaybe<Scalars['DateTime']['input']>;
};

export type CreateUserInput = {
  attribution?: InputMaybe<AttributionData>;
  /** User's email. This will be used as their username. */
  email: Scalars['String']['input'];
  impactAttribution?: InputMaybe<AttributionData>;
  language?: InputMaybe<Scalars['String']['input']>;
  marketingConsentAccepted?: InputMaybe<Scalars['Boolean']['input']>;
  password: Scalars['String']['input'];
  /** User has accepted latest Kontist terms when signing up */
  terms?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Customer = {
  __typename?: 'Customer';
  address?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  taxNumber?: Maybe<Scalars['String']['output']>;
  vatNumber?: Maybe<Scalars['String']['output']>;
};

/** Whether 'Person' or 'Business' */
export enum CustomerType {
  Business = 'BUSINESS',
  Person = 'PERSON'
}

export enum CustomerVettingStatus {
  CustomerUnresponsive = 'CUSTOMER_UNRESPONSIVE',
  InformationReceived = 'INFORMATION_RECEIVED',
  InformationRequested = 'INFORMATION_REQUESTED',
  NotVetted = 'NOT_VETTED',
  NoMatch = 'NO_MATCH',
  PotentialMatch = 'POTENTIAL_MATCH',
  RiskAccepted = 'RISK_ACCEPTED',
  RiskRejected = 'RISK_REJECTED',
  VettingNotRequired = 'VETTING_NOT_REQUIRED'
}

export type DashboardInvoice = {
  __typename?: 'DashboardInvoice';
  amount?: Maybe<Scalars['Int']['output']>;
  dueDate?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  invoiceNumber?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  paidAt?: Maybe<Scalars['DateTime']['output']>;
  status: InvoiceStatusType;
  transactionId?: Maybe<Scalars['ID']['output']>;
};

export type DatevExport = {
  __typename?: 'DatevExport';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  skr: Skr;
  status: DatevExportStatus;
  uploadedAt?: Maybe<Scalars['DateTime']['output']>;
  url?: Maybe<Scalars['String']['output']>;
  withReceipts: Scalars['Boolean']['output'];
  year: Scalars['Int']['output'];
};

export type DatevExportInput = {
  skr: Skr;
  withReceipts: Scalars['Boolean']['input'];
  year: Scalars['Int']['input'];
};

export enum DatevExportStatus {
  Created = 'CREATED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Succeeded = 'SUCCEEDED'
}

export type Declaration = {
  __typename?: 'Declaration';
  amount?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  period: Scalars['String']['output'];
  submissionStatus?: Maybe<SubmissionStatus>;
  uploadedAt?: Maybe<Scalars['DateTime']['output']>;
  year: Scalars['Int']['output'];
};

export type DeclarationApproval = {
  __typename?: 'DeclarationApproval';
  createdAt: Scalars['DateTime']['output'];
  delaySubmission?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  jointDeclaration?: Maybe<Scalars['Boolean']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

export type DeclarationDecline = {
  __typename?: 'DeclarationDecline';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  reason: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type DeclarationStats = {
  __typename?: 'DeclarationStats';
  amount: Scalars['Int']['output'];
  categoryGroups: Array<CategoryGroup>;
  exitedBusinessAssetsWithVat: Array<BusinessAssetResponse>;
  uncategorized: Array<TransactionForAccountingView>;
};

export type DeclarationSubmission = {
  __typename?: 'DeclarationSubmission';
  id: Scalars['Int']['output'];
  isFinal: Scalars['Boolean']['output'];
  isSuccessful: Scalars['Boolean']['output'];
  messages: Array<BizTaxDeclarationResultMessage>;
  period: Scalars['String']['output'];
  submittedAt: Scalars['DateTime']['output'];
  year: Scalars['Int']['output'];
};

export enum DeclarationType {
  Euer = 'EUER',
  GewSt = 'GewSt',
  USt = 'USt',
  UStVa = 'UStVA'
}

export enum DeliveryMethod {
  DeviceSigning = 'DEVICE_SIGNING',
  MobileNumber = 'MOBILE_NUMBER'
}

export type DependentsTaxIds = {
  deTaxId: Scalars['String']['input'];
  id: Scalars['ID']['input'];
};

export type Depreciation = {
  __typename?: 'Depreciation';
  depreciationAmount: Scalars['Float']['output'];
  depreciationMonths: Scalars['Float']['output'];
  startAmount: Scalars['Float']['output'];
  year: Scalars['Float']['output'];
};

export enum DeviceActivityType {
  AppStart = 'APP_START',
  ConsentProvided = 'CONSENT_PROVIDED',
  PasswordReset = 'PASSWORD_RESET'
}

/** Device binding attempts */
export type DeviceBindingRequest = {
  __typename?: 'DeviceBindingRequest';
  address: Scalars['String']['output'];
  confirmedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  deviceId?: Maybe<Scalars['String']['output']>;
  deviceName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  ipAddress: Scalars['String']['output'];
  rejectedAt?: Maybe<Scalars['DateTime']['output']>;
};

export enum DeviceConsentEventType {
  Approved = 'APPROVED',
  Rejected = 'REJECTED'
}

export type DirectDebitFee = {
  __typename?: 'DirectDebitFee';
  amount: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  invoiceStatus: InvoiceStatus;
  name?: Maybe<Scalars['String']['output']>;
  type: TransactionFeeType;
  usedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type Discount = {
  __typename?: 'Discount';
  amount: Scalars['Float']['output'];
  couponIsValid: Scalars['Boolean']['output'];
  description?: Maybe<Scalars['String']['output']>;
  subtitle?: Maybe<Scalars['String']['output']>;
};

export type Document = {
  __typename?: 'Document';
  createdAt: Scalars['DateTime']['output'];
  downloadUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  metadata?: Maybe<DocumentMetadata>;
  name: Scalars['String']['output'];
  note?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type DocumentCategory = {
  __typename?: 'DocumentCategory';
  categoryName: Scalars['String']['output'];
  folderName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
};

export enum DocumentMatchStatus {
  AlreadyHasAsset = 'ALREADY_HAS_ASSET',
  LaterMatch = 'LATER_MATCH',
  ManualMatch = 'MANUAL_MATCH',
  ManualMatchUser = 'MANUAL_MATCH_USER',
  NoMatches = 'NO_MATCHES',
  OtherProviderMatch = 'OTHER_PROVIDER_MATCH',
  TooManyMatches = 'TOO_MANY_MATCHES',
  WrongMatch = 'WRONG_MATCH'
}

export type DocumentMetadata = {
  __typename?: 'DocumentMetadata';
  category: DocumentCategory;
};

export enum DocumentType {
  Expense = 'EXPENSE',
  Invoice = 'INVOICE',
  Voucher = 'VOUCHER'
}

export enum DocumentUploadSource {
  Backoffice = 'BACKOFFICE',
  Email = 'EMAIL',
  EmailFetch = 'EMAIL_FETCH',
  Mobile = 'MOBILE',
  Web = 'WEB'
}

export type DraftTransaction = {
  __typename?: 'DraftTransaction';
  amount?: Maybe<Scalars['Int']['output']>;
  assets: Array<Asset>;
  categoryCode?: Maybe<CategoryCode>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  isCashTransaction: Scalars['Boolean']['output'];
  name?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  paymentDate?: Maybe<Scalars['DateTime']['output']>;
  vatCategoryCode?: Maybe<Scalars['String']['output']>;
  vatRate?: Maybe<VatRate>;
};

export type EmailDocument = {
  __typename?: 'EmailDocument';
  amount?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['DateTime']['output'];
  currency?: Maybe<Scalars['String']['output']>;
  date?: Maybe<Scalars['DateTime']['output']>;
  documentNumber?: Maybe<Scalars['String']['output']>;
  filename: Scalars['String']['output'];
  iban?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  matchStatus?: Maybe<DocumentMatchStatus>;
  /** Returns an array of transactions which potential match with an email document. Note that just a subset of transaction fields gets returned */
  matches?: Maybe<Array<Transaction>>;
  name?: Maybe<Scalars['String']['output']>;
  transactionId?: Maybe<Scalars['ID']['output']>;
  url: Scalars['String']['output'];
};

export type ExitBusinessAssetPayload = {
  exitAmount?: InputMaybe<Scalars['Float']['input']>;
  exitDate: Scalars['String']['input'];
  exitReason: ExitReason;
  isExitedWithVat: Scalars['Boolean']['input'];
  note: Scalars['String']['input'];
};

export enum ExitReason {
  Depreciated = 'DEPRECIATED',
  Lost = 'LOST',
  PrivateUse = 'PRIVATE_USE',
  Sold = 'SOLD'
}

export type FibuFinalCheckTask = {
  __typename?: 'FibuFinalCheckTask';
  status: FibuFinalCheckTaskStatus;
  type: FibuFinalCheckTaskType;
};

export enum FibuFinalCheckTaskStatus {
  Completed = 'COMPLETED',
  Todo = 'TODO'
}

export enum FibuFinalCheckTaskType {
  SubmitAssets = 'SUBMIT_ASSETS',
  SubmitExternalTransactions = 'SUBMIT_EXTERNAL_TRANSACTIONS',
  TaxReceipts = 'TAX_RECEIPTS',
  UploadAdvisor = 'UPLOAD_ADVISOR',
  UploadManual = 'UPLOAD_MANUAL',
  UploadTool = 'UPLOAD_TOOL'
}

export type FilterPreset = {
  value: Scalars['String']['output'];
};

export type FilterPresetInput = {
  insightPresetType?: InputMaybe<InsightPresetType>;
  insightWithPrivateTransactions?: InputMaybe<Scalars['Boolean']['input']>;
  value: Scalars['String']['input'];
  year?: InputMaybe<Scalars['Int']['input']>;
};

/** Commercial registration provided by Solaris */
export type FindResult = {
  __typename?: 'FindResult';
  address: SolarisBusinessAddress;
  legalForm: Scalars['String']['output'];
  legalRepresentatives: Array<BusinessResultLegalRepresentative>;
  name: Scalars['String']['output'];
  registrationDate: Scalars['String']['output'];
  registrationIssuer: Scalars['String']['output'];
  registrationNumber: Scalars['String']['output'];
  taxCountry: Scalars['String']['output'];
};

export type FormDataPair = {
  __typename?: 'FormDataPair';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FrodaLendingEligibility = {
  __typename?: 'FrodaLendingEligibility';
  canRetryOn?: Maybe<Scalars['DateTime']['output']>;
  eligible: Scalars['Boolean']['output'];
};

export enum Gender {
  Female = 'FEMALE',
  Male = 'MALE',
  Neutral = 'NEUTRAL'
}

export type GenericFeature = {
  __typename?: 'GenericFeature';
  name: Scalars['String']['output'];
};

export type GenericFilterPreset = FilterPreset & {
  __typename?: 'GenericFilterPreset';
  value: Scalars['String']['output'];
};

export type GooglePayCardToken = {
  __typename?: 'GooglePayCardToken';
  tokenRefId: Scalars['String']['output'];
  walletId: Scalars['String']['output'];
};

export enum GrantType {
  AuthorizationCode = 'AUTHORIZATION_CODE',
  ClientCredentials = 'CLIENT_CREDENTIALS',
  Password = 'PASSWORD',
  RefreshToken = 'REFRESH_TOKEN'
}

export type IbanInformation = {
  __typename?: 'IBANInformation';
  bankName?: Maybe<Scalars['String']['output']>;
  bic?: Maybe<Scalars['String']['output']>;
  isSepaInstantTransferAvailable: Scalars['Boolean']['output'];
};

export type Icon = {
  __typename?: 'Icon';
  uri: Scalars['String']['output'];
};

export type IdentificationDetails = {
  __typename?: 'IdentificationDetails';
  /** The number of identifications attempted by the user */
  attempts: Scalars['Int']['output'];
  /** The link to use for IDNow identification */
  link?: Maybe<Scalars['String']['output']>;
  /** The user's IDNow identification status */
  status?: Maybe<IdentificationStatus>;
};

export enum IdentificationStatus {
  Aborted = 'ABORTED',
  Canceled = 'CANCELED',
  Created = 'CREATED',
  Expired = 'EXPIRED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  PendingFailed = 'PENDING_FAILED',
  PendingSuccessful = 'PENDING_SUCCESSFUL',
  Successful = 'SUCCESSFUL'
}

export enum IdnowReminderType {
  Email = 'EMAIL',
  Sms = 'SMS'
}

export type Insight = {
  __typename?: 'Insight';
  gross: Scalars['Int']['output'];
  grossAndPrivate: Scalars['Int']['output'];
  net: Scalars['Int']['output'];
  netAndPrivate: Scalars['Int']['output'];
  private: Scalars['Int']['output'];
  vat: Scalars['Int']['output'];
};

export enum InsightPresetType {
  Expense = 'EXPENSE',
  Income = 'INCOME',
  ProfitAndLoss = 'PROFIT_AND_LOSS'
}

export type InsightsFilterPreset = FilterPreset & {
  __typename?: 'InsightsFilterPreset';
  insightPresetType: InsightPresetType;
  insightWithPrivateTransactions?: Maybe<Scalars['Boolean']['output']>;
  value: Scalars['String']['output'];
};

export enum IntegrationType {
  Fastbill = 'FASTBILL',
  Lexoffice = 'LEXOFFICE'
}

export enum InternationalCustomers {
  Eu = 'EU',
  None = 'NONE',
  Worldwide = 'WORLDWIDE'
}

export type Invoice = {
  __typename?: 'Invoice';
  customer?: Maybe<Customer>;
  dueDate?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  invoiceNumber?: Maybe<Scalars['Float']['output']>;
  invoiceSettingsId?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  /** A list of products from the invoice */
  products?: Maybe<Array<InvoiceProductOutput>>;
  status: Scalars['String']['output'];
  transactionId: Scalars['ID']['output'];
};

export type InvoiceCustomerInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  taxNumber?: InputMaybe<Scalars['String']['input']>;
  vatNumber?: InputMaybe<Scalars['String']['input']>;
};

export type InvoiceCustomerOutput = {
  __typename?: 'InvoiceCustomerOutput';
  address?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  taxNumber?: Maybe<Scalars['String']['output']>;
  vatNumber?: Maybe<Scalars['String']['output']>;
};

export type InvoiceInput = {
  customerId?: InputMaybe<Scalars['String']['input']>;
  dueDate?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  invoiceSettingsId?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  products?: InputMaybe<Array<InvoiceProductInput>>;
  status: Scalars['String']['input'];
};

export type InvoiceLogoFormDataPair = {
  __typename?: 'InvoiceLogoFormDataPair';
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type InvoiceOutput = {
  __typename?: 'InvoiceOutput';
  customer?: Maybe<InvoiceCustomerOutput>;
  customerId?: Maybe<Scalars['String']['output']>;
  dueDate?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  invoiceNumber?: Maybe<Scalars['Float']['output']>;
  invoiceSettingsId?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  products?: Maybe<Array<InvoiceProductOutput>>;
  status: Scalars['String']['output'];
};

export type InvoicePageInfo = {
  __typename?: 'InvoicePageInfo';
  currentPage: Scalars['Int']['output'];
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
};

export type InvoiceProductInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  price?: InputMaybe<Scalars['Float']['input']>;
  quantity?: InputMaybe<Scalars['Float']['input']>;
  vat?: InputMaybe<Scalars['String']['input']>;
};

export type InvoiceProductOutput = {
  __typename?: 'InvoiceProductOutput';
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  price?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  vat?: Maybe<Scalars['String']['output']>;
};

export type InvoiceSettingsInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  /** Number of days which get added to today's date to create a default value for due date on invoice creation form */
  dueDateDefaultOffset?: InputMaybe<Scalars['Float']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  nextInvoiceNumber?: InputMaybe<Scalars['Float']['input']>;
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  postCode?: InputMaybe<Scalars['String']['input']>;
  senderName?: InputMaybe<Scalars['String']['input']>;
  streetLine?: InputMaybe<Scalars['String']['input']>;
  taxNumber?: InputMaybe<Scalars['String']['input']>;
  vatNumber?: InputMaybe<Scalars['String']['input']>;
};

export type InvoiceSettingsOutput = {
  __typename?: 'InvoiceSettingsOutput';
  city?: Maybe<Scalars['String']['output']>;
  companyName?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  /** Number of days which get added to today's date to create a default value for due date on invoice creation form */
  dueDateDefaultOffset?: Maybe<Scalars['Float']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  /** If a user's setting has a logoPath, we calculate a url to the thumbnail from it */
  logoUrl?: Maybe<Scalars['String']['output']>;
  nextInvoiceNumber?: Maybe<Scalars['Float']['output']>;
  phoneNumber?: Maybe<Scalars['String']['output']>;
  postCode?: Maybe<Scalars['String']['output']>;
  senderName?: Maybe<Scalars['String']['output']>;
  streetLine?: Maybe<Scalars['String']['output']>;
  taxNumber?: Maybe<Scalars['String']['output']>;
  vatNumber?: Maybe<Scalars['String']['output']>;
};

export enum InvoiceStatus {
  Closed = 'CLOSED',
  Open = 'OPEN',
  Pending = 'PENDING',
  Rejected = 'REJECTED'
}

export enum InvoiceStatusType {
  Created = 'CREATED',
  Draft = 'DRAFT',
  Paid = 'PAID',
  Sent = 'SENT'
}

export type InvoicingDashboardData = {
  __typename?: 'InvoicingDashboardData';
  data: Array<DashboardInvoice>;
  pageInfo: InvoicePageInfo;
};

export type Jwe = {
  alg: Scalars['String']['input'];
  enc: Scalars['String']['input'];
};

export type Jwk = {
  e: Scalars['String']['input'];
  kty: Scalars['String']['input'];
  n: Scalars['String']['input'];
};

export enum LegalForm {
  Ador = 'ADOR',
  Ag = 'AG',
  Agcokg = 'AGCOKG',
  Amt = 'AMT',
  AtAg = 'AT_AG',
  AtAmt = 'AT_AMT',
  AtEg = 'AT_EG',
  AtEv = 'AT_EV',
  AtGbr = 'AT_GBR',
  AtGesmbh = 'AT_GESMBH',
  AtGmbh = 'AT_GMBH',
  AtGmbhCoKg = 'AT_GMBH_CO_KG',
  AtKg = 'AT_KG',
  AtKor = 'AT_KOR',
  AtOhg = 'AT_OHG',
  AtSe = 'AT_SE',
  AtSelfEmployed = 'AT_SELF_EMPLOYED',
  AtSoleProprietorship = 'AT_SOLE_PROPRIETORSHIP',
  AtStiftungen = 'AT_STIFTUNGEN',
  BeSa = 'BE_SA',
  BeSc = 'BE_SC',
  BeSca = 'BE_SCA',
  BeScri = 'BE_SCRI',
  BeScs = 'BE_SCS',
  BeSe = 'BE_SE',
  BeSelfEmployed = 'BE_SELF_EMPLOYED',
  BeSep = 'BE_SEP',
  BeSf = 'BE_SF',
  BeSnc = 'BE_SNC',
  BeSoleProprietorship = 'BE_SOLE_PROPRIETORSHIP',
  BeSprl = 'BE_SPRL',
  BeSprlu = 'BE_SPRLU',
  BgAd = 'BG_AD',
  BgKd = 'BG_KD',
  BgKda = 'BG_KDA',
  BgOod = 'BG_OOD',
  BgSd = 'BG_SD',
  BgSelfEmployed = 'BG_SELF_EMPLOYED',
  BgSoleProprietorship = 'BG_SOLE_PROPRIETORSHIP',
  ChDeAg = 'CH_DE_AG',
  ChDeEg = 'CH_DE_EG',
  ChDeGmbh = 'CH_DE_GMBH',
  ChDeKg = 'CH_DE_KG',
  ChDeKig = 'CH_DE_KIG',
  ChDeKmg = 'CH_DE_KMG',
  ChDeKomag = 'CH_DE_KOMAG',
  ChFrSa = 'CH_FR_SA',
  ChFrSarl = 'CH_FR_SARL',
  ChFrSca = 'CH_FR_SCA',
  ChFrScm = 'CH_FR_SCM',
  ChFrSnc = 'CH_FR_SNC',
  ChFrSs = 'CH_FR_SS',
  ChItSa = 'CH_IT_SA',
  ChItSac = 'CH_IT_SAC',
  ChItSaca = 'CH_IT_SACA',
  ChItSagl = 'CH_IT_SAGL',
  ChItSnc = 'CH_IT_SNC',
  ChItSs = 'CH_IT_SS',
  ChSe = 'CH_SE',
  ChSelfEmployed = 'CH_SELF_EMPLOYED',
  ChSoleProprietorship = 'CH_SOLE_PROPRIETORSHIP',
  CzAs = 'CZ_AS',
  CzDruzstvo = 'CZ_DRUZSTVO',
  CzFyzickaOsoba = 'CZ_FYZICKA_OSOBA',
  CzKs = 'CZ_KS',
  CzSelfEmployed = 'CZ_SELF_EMPLOYED',
  CzSoleProprietorship = 'CZ_SOLE_PROPRIETORSHIP',
  CzSro = 'CZ_SRO',
  CzVos = 'CZ_VOS',
  Eg = 'EG',
  Ek = 'EK',
  EsSa = 'ES_SA',
  EsSas = 'ES_SAS',
  EsSau = 'ES_SAU',
  EsSc = 'ES_SC',
  EsSca = 'ES_SCA',
  EsScop = 'ES_SCOP',
  EsSe = 'ES_SE',
  EsSelfEmployed = 'ES_SELF_EMPLOYED',
  EsSlne = 'ES_SLNE',
  EsSlu = 'ES_SLU',
  EsSoleProprietorship = 'ES_SOLE_PROPRIETORSHIP',
  EsSpro = 'ES_SPRO',
  EsSrc = 'ES_SRC',
  EsSrl = 'ES_SRL',
  Ev = 'EV',
  ForeignCorporation = 'FOREIGN_CORPORATION',
  FrAe = 'FR_AE',
  FrEi = 'FR_EI',
  FrEurl = 'FR_EURL',
  FrSa = 'FR_SA',
  FrSarl = 'FR_SARL',
  FrSas = 'FR_SAS',
  FrSc = 'FR_SC',
  FrSca = 'FR_SCA',
  FrScop = 'FR_SCOP',
  FrScs = 'FR_SCS',
  FrSe = 'FR_SE',
  FrSelarl = 'FR_SELARL',
  FrSelfEmployed = 'FR_SELF_EMPLOYED',
  FrSnc = 'FR_SNC',
  FrSoleProprietorship = 'FR_SOLE_PROPRIETORSHIP',
  Gbr = 'GBR',
  GbCops = 'GB_COPS',
  GbLp = 'GB_LP',
  GbLtd = 'GB_LTD',
  GbPartnership = 'GB_PARTNERSHIP',
  GbPlc = 'GB_PLC',
  GbPrcu = 'GB_PRCU',
  GbPucu = 'GB_PUCU',
  GbSe = 'GB_SE',
  GbSelfEmployed = 'GB_SELF_EMPLOYED',
  GbSoleProprietorship = 'GB_SOLE_PROPRIETORSHIP',
  GbUas = 'GB_UAS',
  Gmbh = 'GMBH',
  GmbhCoKg = 'GMBH_CO_KG',
  GmbhIGr = 'GMBH_I_GR',
  HrDd = 'HR_DD',
  HrDoo = 'HR_DOO',
  HrJdoo = 'HR_JDOO',
  HrJtd = 'HR_JTD',
  HrKd = 'HR_KD',
  HrOrta = 'HR_ORTA',
  HrSelfEmployed = 'HR_SELF_EMPLOYED',
  HrSoleProprietorship = 'HR_SOLE_PROPRIETORSHIP',
  HuBt = 'HU_BT',
  HuKft = 'HU_KFT',
  HuKkt = 'HU_KKT',
  HuNyrt = 'HU_NYRT',
  HuOrta = 'HU_ORTA',
  HuSelfEmployed = 'HU_SELF_EMPLOYED',
  HuSoleProprietorship = 'HU_SOLE_PROPRIETORSHIP',
  ItSapa = 'IT_SAPA',
  ItSas = 'IT_SAS',
  ItScarl = 'IT_SCARL',
  ItScop = 'IT_SCOP',
  ItScpa = 'IT_SCPA',
  ItSe = 'IT_SE',
  ItSelfEmployed = 'IT_SELF_EMPLOYED',
  ItSnc = 'IT_SNC',
  ItSoleProprietorship = 'IT_SOLE_PROPRIETORSHIP',
  ItSpa = 'IT_SPA',
  ItSrl = 'IT_SRL',
  ItSs = 'IT_SS',
  Kdor = 'KDOR',
  Kg = 'KG',
  Kgaa = 'KGAA',
  Ltd = 'LTD',
  LuAsbl = 'LU_ASBL',
  LuFon = 'LU_FON',
  LuSa = 'LU_SA',
  LuSarl = 'LU_SARL',
  LuSarls = 'LU_SARLS',
  LuSc = 'LU_SC',
  LuSca = 'LU_SCA',
  LuScop = 'LU_SCOP',
  LuScs = 'LU_SCS',
  LuScsp = 'LU_SCSP',
  LuSe = 'LU_SE',
  LuSeca = 'LU_SECA',
  LuSelfEmployed = 'LU_SELF_EMPLOYED',
  LuSnc = 'LU_SNC',
  LuSoleProprietorship = 'LU_SOLE_PROPRIETORSHIP',
  LuSp = 'LU_SP',
  Municipality = 'MUNICIPALITY',
  MunicipalCompany = 'MUNICIPAL_COMPANY',
  Nev = 'NEV',
  NlBv = 'NL_BV',
  NlCopv = 'NL_COPV',
  NlCv = 'NL_CV',
  NlCvoa = 'NL_CVOA',
  NlMts = 'NL_MTS',
  NlNv = 'NL_NV',
  NlSe = 'NL_SE',
  NlSelfEmployed = 'NL_SELF_EMPLOYED',
  NlSoleProprietorship = 'NL_SOLE_PROPRIETORSHIP',
  NlSticht = 'NL_STICHT',
  NlVereniging = 'NL_VERENIGING',
  NlVof = 'NL_VOF',
  None = 'NONE',
  Ohg = 'OHG',
  Partg = 'PARTG',
  PlOther = 'PL_OTHER',
  PlSa = 'PL_SA',
  PlSe = 'PL_SE',
  PlSelfEmployed = 'PL_SELF_EMPLOYED',
  PlSka = 'PL_SKA',
  PlSpj = 'PL_SPJ',
  PlSpk = 'PL_SPK',
  PlSpzoo = 'PL_SPZOO',
  PrivatePerson = 'PRIVATE_PERSON',
  PtCop = 'PT_COP',
  PtEirl = 'PT_EIRL',
  PtLda = 'PT_LDA',
  PtSa = 'PT_SA',
  PtSc = 'PT_SC',
  PtSciv = 'PT_SCIV',
  PtSe = 'PT_SE',
  PtSelfEmployed = 'PT_SELF_EMPLOYED',
  PtSnc = 'PT_SNC',
  PtSoleProprietorship = 'PT_SOLE_PROPRIETORSHIP',
  PtSuni = 'PT_SUNI',
  RoSa = 'RO_SA',
  RoSca = 'RO_SCA',
  RoScs = 'RO_SCS',
  RoSelfEmployed = 'RO_SELF_EMPLOYED',
  RoSnc = 'RO_SNC',
  RoSoleProprietorship = 'RO_SOLE_PROPRIETORSHIP',
  RoSrl = 'RO_SRL',
  RsAd = 'RS_AD',
  RsDoo = 'RS_DOO',
  RsKd = 'RS_KD',
  RsOd = 'RS_OD',
  RsSelfEmployed = 'RS_SELF_EMPLOYED',
  RsSoleProprietorship = 'RS_SOLE_PROPRIETORSHIP',
  SavingsBank = 'SAVINGS_BANK',
  Se = 'SE',
  Secokg = 'SECOKG',
  SelfEmployed = 'SELF_EMPLOYED',
  SiDd = 'SI_DD',
  SiDno = 'SI_DNO',
  SiDoo = 'SI_DOO',
  SiKd = 'SI_KD',
  SiKdd = 'SI_KDD',
  SiSelfEmployed = 'SI_SELF_EMPLOYED',
  SiSoleProprietorship = 'SI_SOLE_PROPRIETORSHIP',
  SoleProprietorship = 'SOLE_PROPRIETORSHIP',
  Stiftungen = 'STIFTUNGEN',
  TrAdiSir = 'TR_ADI_SIR',
  TrAs = 'TR_AS',
  TrKollSti = 'TR_KOLL_STI',
  TrKomSti = 'TR_KOM_STI',
  TrLs = 'TR_LS',
  TrSelfEmployed = 'TR_SELF_EMPLOYED',
  TrSoleProprietorship = 'TR_SOLE_PROPRIETORSHIP',
  Ug = 'UG',
  UgIGr = 'UG_I_GR'
}

export type LegalRepresentative = {
  __typename?: 'LegalRepresentative';
  businessId: Scalars['String']['output'];
  firstName: Scalars['String']['output'];
  id: Scalars['String']['output'];
  lastName: Scalars['String']['output'];
};

export type LegalRepresentativeSignupData = {
  __typename?: 'LegalRepresentativeSignupData';
  email?: Maybe<Scalars['String']['output']>;
  firstName: Scalars['String']['output'];
  id: Scalars['String']['output'];
  identificationStatus?: Maybe<IdentificationStatus>;
  isCurrentUser: Scalars['Boolean']['output'];
  lastName: Scalars['String']['output'];
  userId: Scalars['Float']['output'];
};

export enum MaximumCashTransactionsPercentage {
  Hundred = 'HUNDRED',
  Null = 'NULL',
  Ten = 'TEN'
}

export type MissingTaxAssetsFilterPreset = FilterPreset & {
  __typename?: 'MissingTaxAssetsFilterPreset';
  value: Scalars['String']['output'];
  year: Scalars['Int']['output'];
};

export type Money = {
  __typename?: 'Money';
  /** The amount the user pays */
  amount: Scalars['Int']['output'];
  /** The amount the user saves */
  discountAmount: Scalars['Int']['output'];
  /** The amount the user saves in percentage */
  discountPercentage?: Maybe<Scalars['Int']['output']>;
  /** The amount plus discount amount */
  fullAmount?: Maybe<Scalars['Int']['output']>;
};

export type Municipality = {
  __typename?: 'Municipality';
  name: Scalars['String']['output'];
  taxRate: Scalars['Float']['output'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Activate a card */
  activateCard: Card;
  /** Activate Overdraft Application  - only available for Kontist Application */
  activateOverdraft?: Maybe<Overdraft>;
  /** Add restricted key to selected device */
  addDeviceKey: Scalars['String']['output'];
  /** Adds Google Pay card token reference id for given wallet id */
  addGooglePayCardToken: GooglePayCardToken;
  /** Send Lead data to designated Zap to redirect lead to Agreas */
  agerasLeadRedirect: MutationResult;
  approveDeclaration: DeclarationApproval;
  authorizeChangeRequest: AuthorizeChangeRequestResponse;
  /** Cancel an existing Timed Order or Standing Order */
  cancelTransfer: ConfirmationRequestOrTransfer;
  /**
   * Adds card to given wallet
   * @deprecated Please use more secure requestCardPushProvisioning and confirmCardPushProvisioning
   */
  cardPushProvisioning: PushProvisioningOutput;
  /** Categorize transaction for VAT declaration */
  categorizeTransactionForDeclaration: CategorizeTransactionForDeclarationResponse;
  /** Set a new PIN, needs to be confirmed */
  changeCardPIN: ConfirmationRequest;
  /** Encrypted card PIN change */
  changeCardPINEncrypted: Card;
  /** Encrypted card PIN change with Change Request */
  changeCardPINWithChangeRequest: ConfirmationRequest;
  /** Block or unblock or close a card */
  changeCardStatus: Card;
  closeSubAccount: MutationResult;
  confirmBizTaxBookkeeping: BizTaxDeclarationBookkeepingConfirmation;
  /** Confirm a Standing Order cancellation */
  confirmCancelTransfer: Transfer;
  /** Confirms adding card to Apple/Google Pay wallet */
  confirmCardPushProvisioning: PushProvisioningOutput;
  /** Confirm a PIN change request */
  confirmChangeCardPIN: ConfirmationStatus;
  confirmChangeRequest: ConfirmChangeRequestResponse;
  confirmDirectDebitRefund: MutationResult;
  confirmFraud: ConfirmFraudResponse;
  /** Confirm a transfer creation */
  confirmTransfer: Transfer;
  /** Confirm the transfers creation */
  confirmTransfers: BatchTransfer;
  /** Confirms update of user fields on solaris */
  confirmUpdateSolarisUser: User;
  /** Connect user to a bookkeeping partner */
  connectIntegration: MutationResult;
  /** Creates user activity for device monitoring */
  createActivityForDeviceMonitoring: MutationResult;
  createBeneficialOwner: BeneficialOwner;
  createBeneficialOwnersOnSolaris: Array<BeneficialOwner>;
  /** Creates an user's business address */
  createBusinessAddress: BusinessAddress;
  createBusinessIdentification: BusinessIdentification;
  /** Create a new card */
  createCard: Card;
  /** Create an OAuth2 client */
  createClient: Client;
  /** Records consent from the given person to collect device fingerprints on their registered device */
  createConsentForDeviceMonitoring?: Maybe<Scalars['String']['output']>;
  /** Create contact */
  createContact: Contact;
  /** Creates a DATEV export */
  createDatevExport: DatevExport;
  /** Create device binding request */
  createDeviceBindingRequest: DeviceBindingRequest;
  /** Creates a draft external transaction entry */
  createDraftTransaction: CreateDraftTransactionResponse;
  /** Create a draft transaction Asset and obtain an upload config */
  createDraftTransactionAsset: CreateAssetResponse;
  /** Creates draft external transactions entries */
  createDraftTransactions: Array<CreateDraftTransactionResponse>;
  createIntraCustomerTransfer: CreateIntraCustomerTransferPayload;
  /** The logo a user can add to his invoice. The path to it is stored in invoiceSettings */
  createInvoiceLogo: CreateInvoiceLogoResponse;
  createLegalRepresentative: LegalRepresentative;
  createLegalRepresentativesOnSolaris: Array<LegalRepresentative>;
  /** Create an OCR Asset and obtain an upload config */
  createOCRAsset: CreateAssetResponse;
  createQuestionnaireDocumentAsset: CreateAssetResponse;
  createReview: CreateReviewResponse;
  /** Create user's taxNumber */
  createTaxNumber: TaxNumber;
  createTopUp: TopUpCreationResult;
  /** Create a transaction Asset and obtain an upload config */
  createTransactionAsset: CreateAssetResponse;
  /** Create transaction splits */
  createTransactionSplits: RawTransactionProjection;
  /** Create a transfer. The transfer's type will be determined based on the provided input */
  createTransfer: ConfirmationRequest;
  /** Create multiple transfers at once. Only regular SEPA Transfers are supported */
  createTransfers: ConfirmationRequest;
  /** Create a new user */
  createUser: PublicMutationResult;
  createUserEmailAlias: MutationResult;
  declineDeclaration: DeclarationDecline;
  declineTrial: MutationResult;
  /** Remove an Asset */
  deleteAsset: MutationResult;
  deleteBeneficialOwner: MutationResult;
  /** Delete bound device */
  deleteBoundDevice: Scalars['Boolean']['output'];
  /** Delete business asset */
  deleteBusinessAsset: MutationResult;
  /** Delete an OAuth2 client */
  deleteClient: Client;
  /** Delete contact */
  deleteContact: MutationResult;
  /** Deletes document */
  deleteDocument: MutationResult;
  /** Deletes draft transaction */
  deleteDraftTransaction: MutationResult;
  deleteEmailDocument: MutationResult;
  /** Deletes external transaction */
  deleteExternalTransaction: MutationResult;
  /** Deletes Google Pay card token reference id for given wallet id */
  deleteGooglePayCardToken: GooglePayCardToken;
  deleteInvoice: MutationResult;
  /** Deletes the logo of a user's settings entry */
  deleteInvoiceLogo: MutationResult;
  deleteLegalRepresentative: MutationResult;
  deletePaymentMethod: Scalars['Boolean']['output'];
  deleteQuestionnaireDocument: MutationResult;
  /** Delete user's taxNumber */
  deleteTaxNumber: MutationResult;
  /** Remove an Asset from the Transaction */
  deleteTransactionAsset: MutationResult;
  /** Delete transaction splits */
  deleteTransactionSplits: RawTransactionProjection;
  dismissBanner: MutationResult;
  duplicateInvoice: InvoiceOutput;
  /** Exit business asset */
  exitBusinessAsset: MutationResult;
  /** Performs OCR on the asset and extracts data */
  extractOCRData?: Maybe<OcrResult>;
  /** Confirm and validate an Asset upload as completed */
  finalizeAssetUpload: Asset;
  finalizeTaxCase: TaxCase;
  /** Confirm and validate an Asset upload as completed */
  finalizeTransactionAssetUpload: TransactionAsset;
  /** Exports list of receipts for given time frame */
  generateReceiptExport: ReceiptExportResult;
  /** Check if user is eligible for lending */
  getLendingEligibility: FrodaLendingEligibility;
  initDirectDebitRefund: AuthorizeThroughDeviceSigningOrMobileNumberResponse;
  markViewAsSeen: MutationResult;
  matchEmailDocumentToTransaction: MutationResult;
  /** Onboards user if needed */
  onboardUser: Scalars['String']['output'];
  postponeQuestionnaireAnswer: Questionnaire;
  previewBizTaxDeclaration: BizTaxDeclarationSubmission;
  refundDirectDebit: MutationResult;
  /** Close and order new card. Call when customer's card is damaged */
  reorderCard: Card;
  /** Call when customer's card is lost or stolen */
  replaceCard: Card;
  /** Adds card to Apple/Google Pay wallet */
  requestCardPushProvisioning: AuthorizeChangeRequestResponse;
  /** Request access url */
  requestFrodaAccessUrl?: Maybe<Scalars['String']['output']>;
  /** Create a new identification if applicable */
  requestIdentification: IdentificationDetails;
  /** Create Overdraft Application  - only available for Kontist Application */
  requestOverdraft?: Maybe<Overdraft>;
  requestSubAccountOpening: MutationResult;
  /** Reset UStVA declaration */
  resetDeclaration: MutationResult;
  resetLastQuestionnaireAnswer: Questionnaire;
  resetQuestionnaire: MutationResult;
  /** Set the card holder representation for the customer */
  setCardHolderRepresentation: Scalars['String']['output'];
  /** Allow user to sign Power of Attorney */
  signPOA: MutationResult;
  /** Allow user to sign the seizure payment order */
  signSeizurePaymentOrder: MutationResult;
  skipIncomeTax: TaxCase;
  startQuestionnaire: Questionnaire;
  submitBizTaxDeclaration: BizTaxDeclarationSubmission;
  submitBookkeepingQuestionnaire: Questionnaire;
  submitComplianceQuestions: BusinessIdentification;
  /** Submits UStVA declaration */
  submitDeclaration: Declaration;
  /** Submit answer to a question */
  submitQuestionSet: Scalars['Boolean']['output'];
  submitQuestionnaireAnswer: Questionnaire;
  /** Subscribe user to a plan */
  subscribeToPlan: UserSubscription;
  /** Terminate Overdraft  - only available for Kontist Application */
  terminateOverdraft?: Maybe<MutationResult>;
  updateBeneficialOwner: BeneficialOwner;
  updateBizTaxIsRelevant: BizTaxDeclarationIsRelevant;
  updateBusinessIdentification: BusinessIdentification;
  /** Update settings (e.g. limits) */
  updateCardSettings: CardSettings;
  /** Update an OAuth2 client */
  updateClient: Client;
  /** Records change of consent to collect device fingerprints on their registered device */
  updateConsentForDeviceMonitoring?: Maybe<MutationResult>;
  /** Update contact */
  updateContact: Contact;
  /** Update device binding request */
  updateDeviceBindingRequest: Scalars['Boolean']['output'];
  /** Updates document meta */
  updateDocument: Document;
  /** Updates draft external transaction entry. Returns null if finalized transaction was created */
  updateDraftTransaction?: Maybe<DraftTransaction>;
  /** Updates external transaction */
  updateExternalTransaction: RawTransactionProjection;
  updateInvoice: InvoiceOutput;
  updateInvoiceCustomer: InvoiceCustomerOutput;
  updateInvoiceSettings: InvoiceSettingsOutput;
  updateLegalRepresentative: LegalRepresentative;
  /** Updates overdraft application timestamps for rejected and offered overdraft screens - only available for Kontist Application */
  updateOverdraft?: Maybe<Overdraft>;
  updateReview: MutationResult;
  /** Update user fields on solaris */
  updateSolarisUser: UserOrAuthResponse;
  updateSubAccount: SubAccount;
  /** Update user's subscription plan */
  updateSubscriptionPlan: UpdateSubscriptionPlanResult;
  /** Updates user's taxNumber */
  updateTaxNumber: TaxNumber;
  /** Update individual tax-related settings per year */
  updateTaxYearSettings: Array<TaxYearSetting>;
  /** Change Terms And Conditions confirmation status */
  updateTermsAndConditions: TermsAndConditions;
  /** Categorize a transaction with an optional custom booking date for VAT or Tax categories, and add a personal note */
  updateTransaction: Transaction;
  /** Update transaction splits */
  updateTransactionSplits: RawTransactionProjection;
  updateTransfer: ConfirmationRequestOrTransfer;
  /** Update the push-notifications a user should receive */
  updateUserNotifications: Array<Notification>;
  /** Update user signup information */
  updateUserSignupInformation: MutationResult;
  /** Update user's tax details */
  updateUserTaxDetails: MutationResult;
  updateVatYearSetting: VatYearSetting;
  upsertBusiness: Business;
  /** Submits UStVA declaration */
  upsertDeclaration: Declaration;
  /** Create or update products that can be linked to the invoice(s) */
  upsertProducts: Array<Product>;
  upsertQuestionnaireDocument: QuestionnaireDocument;
  /** Upsert user tour */
  upsertUserTour: UserTour;
  userConfirmation: MutationResult;
  /** Returns encrypted card details for virtual card */
  virtualCardDetails: Scalars['String']['output'];
  whitelistCard: WhitelistCardResponse;
};


export type MutationActivateCardArgs = {
  id: Scalars['String']['input'];
  verificationToken?: InputMaybe<Scalars['String']['input']>;
};


export type MutationAddDeviceKeyArgs = {
  deviceId: Scalars['String']['input'];
  key: Scalars['String']['input'];
  signature: Scalars['String']['input'];
};


export type MutationAddGooglePayCardTokenArgs = {
  id: Scalars['String']['input'];
  tokenRefId: Scalars['String']['input'];
  walletId: Scalars['String']['input'];
};


export type MutationApproveDeclarationArgs = {
  payload: CreateDeclarationApprovalInput;
};


export type MutationAuthorizeChangeRequestArgs = {
  changeRequestId: Scalars['String']['input'];
  deviceId: Scalars['String']['input'];
};


export type MutationCancelTransferArgs = {
  deliveryMethod?: InputMaybe<DeliveryMethod>;
  deviceId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  type: TransferType;
};


export type MutationCardPushProvisioningArgs = {
  android?: InputMaybe<PushProvisioningAndroidInput>;
  cardId: Scalars['String']['input'];
  ios?: InputMaybe<PushProvisioningIosInput>;
};


export type MutationCategorizeTransactionForDeclarationArgs = {
  businessAssetInput?: InputMaybe<BusinessAssetInput>;
  category?: InputMaybe<TransactionCategory>;
  categoryCode?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  isSplit?: InputMaybe<Scalars['Boolean']['input']>;
  vatCategoryCode?: InputMaybe<Scalars['String']['input']>;
};


export type MutationChangeCardPinArgs = {
  id: Scalars['String']['input'];
  pin: Scalars['String']['input'];
};


export type MutationChangeCardPinEncryptedArgs = {
  id: Scalars['String']['input'];
  payload: ChangeCardPinEncryptedInput;
};


export type MutationChangeCardPinWithChangeRequestArgs = {
  id: Scalars['String']['input'];
  payload: ChangeCardPinWithChangeRequestInput;
};


export type MutationChangeCardStatusArgs = {
  action: CardAction;
  id: Scalars['String']['input'];
};


export type MutationCloseSubAccountArgs = {
  publicId: Scalars['String']['input'];
};


export type MutationConfirmBizTaxBookkeepingArgs = {
  year: Scalars['Int']['input'];
};


export type MutationConfirmCancelTransferArgs = {
  authorizationToken?: InputMaybe<Scalars['String']['input']>;
  confirmationId: Scalars['String']['input'];
  deviceId?: InputMaybe<Scalars['String']['input']>;
  signature?: InputMaybe<Scalars['String']['input']>;
  type: TransferType;
};


export type MutationConfirmCardPushProvisioningArgs = {
  cardId: Scalars['String']['input'];
  payload: ConfirmChangeRequestArgs;
};


export type MutationConfirmChangeCardPinArgs = {
  authorizationToken: Scalars['String']['input'];
  confirmationId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


export type MutationConfirmChangeRequestArgs = {
  authorizationToken?: InputMaybe<Scalars['String']['input']>;
  changeRequestId: Scalars['String']['input'];
  deviceId: Scalars['String']['input'];
  signature?: InputMaybe<Scalars['String']['input']>;
};


export type MutationConfirmDirectDebitRefundArgs = {
  changeRequestId: Scalars['String']['input'];
  deviceId: Scalars['String']['input'];
  signature?: InputMaybe<Scalars['String']['input']>;
  token?: InputMaybe<Scalars['String']['input']>;
};


export type MutationConfirmTransferArgs = {
  authorizationToken?: InputMaybe<Scalars['String']['input']>;
  confirmationId: Scalars['String']['input'];
  deviceId?: InputMaybe<Scalars['String']['input']>;
  signature?: InputMaybe<Scalars['String']['input']>;
};


export type MutationConfirmTransfersArgs = {
  authorizationToken: Scalars['String']['input'];
  confirmationId: Scalars['String']['input'];
};


export type MutationConfirmUpdateSolarisUserArgs = {
  customerType?: InputMaybe<CustomerType>;
  payload: ConfirmChangeRequestArgs;
};


export type MutationConnectIntegrationArgs = {
  authorizationData: Scalars['String']['input'];
  type: IntegrationType;
};


export type MutationCreateActivityForDeviceMonitoringArgs = {
  activityType: DeviceActivityType;
};


export type MutationCreateBeneficialOwnerArgs = {
  data: CreateBeneficialOwnerInput;
};


export type MutationCreateBusinessAddressArgs = {
  payload: CreateBusinessAddressInput;
};


export type MutationCreateCardArgs = {
  cardHolderRepresentation?: InputMaybe<Scalars['String']['input']>;
  type: CardType;
};


export type MutationCreateClientArgs = {
  client: CreateClientInput;
};


export type MutationCreateConsentForDeviceMonitoringArgs = {
  eventType: DeviceConsentEventType;
};


export type MutationCreateContactArgs = {
  payload: CreateContactArgs;
};


export type MutationCreateDatevExportArgs = {
  payload: DatevExportInput;
};


export type MutationCreateDeviceBindingRequestArgs = {
  deviceId?: InputMaybe<Scalars['String']['input']>;
  deviceName: Scalars['String']['input'];
};


export type MutationCreateDraftTransactionArgs = {
  fileName: Scalars['String']['input'];
};


export type MutationCreateDraftTransactionAssetArgs = {
  filetype: Scalars['String']['input'];
  name: Scalars['String']['input'];
  transactionId: Scalars['ID']['input'];
};


export type MutationCreateDraftTransactionsArgs = {
  payload: Array<CreateDraftTransactionInput>;
};


export type MutationCreateIntraCustomerTransferArgs = {
  input: CreateIntraCustomerTransferInput;
};


export type MutationCreateInvoiceLogoArgs = {
  filetype: Scalars['String']['input'];
};


export type MutationCreateLegalRepresentativeArgs = {
  data: CreateLegalRepresentativeInput;
};


export type MutationCreateOcrAssetArgs = {
  filetype: Scalars['String']['input'];
  name: Scalars['String']['input'];
};


export type MutationCreateQuestionnaireDocumentAssetArgs = {
  filetype: Scalars['String']['input'];
  name: Scalars['String']['input'];
  questionnaireDocumentId: Scalars['ID']['input'];
};


export type MutationCreateReviewArgs = {
  platform: ReviewTriggerPlatform;
  triggerName: ReviewTriggerName;
};


export type MutationCreateTaxNumberArgs = {
  payload: CreateTaxNumberInput;
};


export type MutationCreateTopUpArgs = {
  topUpData: TopUpInput;
};


export type MutationCreateTransactionAssetArgs = {
  assetableType?: InputMaybe<Scalars['String']['input']>;
  filetype: Scalars['String']['input'];
  name: Scalars['String']['input'];
  transactionId: Scalars['ID']['input'];
  uploadPlatform?: InputMaybe<RequestPlatform>;
};


export type MutationCreateTransactionSplitsArgs = {
  splits: Array<CreateTransactionSplitsInput>;
  transactionId: Scalars['ID']['input'];
};


export type MutationCreateTransferArgs = {
  deliveryMethod?: InputMaybe<DeliveryMethod>;
  deviceId?: InputMaybe<Scalars['String']['input']>;
  transfer: CreateTransferInput;
};


export type MutationCreateTransfersArgs = {
  transfers: Array<CreateSepaTransferInput>;
};


export type MutationCreateUserArgs = {
  payload: CreateUserInput;
};


export type MutationCreateUserEmailAliasArgs = {
  alias: Scalars['String']['input'];
  hash: Scalars['String']['input'];
};


export type MutationDeclineDeclarationArgs = {
  payload: CreateDeclarationDeclineInput;
};


export type MutationDeleteAssetArgs = {
  assetId: Scalars['ID']['input'];
};


export type MutationDeleteBeneficialOwnerArgs = {
  id: Scalars['String']['input'];
};


export type MutationDeleteBoundDeviceArgs = {
  deviceId: Scalars['String']['input'];
};


export type MutationDeleteBusinessAssetArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteClientArgs = {
  id: Scalars['String']['input'];
};


export type MutationDeleteContactArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteDocumentArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteDraftTransactionArgs = {
  id: Scalars['String']['input'];
};


export type MutationDeleteEmailDocumentArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteExternalTransactionArgs = {
  id: Scalars['String']['input'];
};


export type MutationDeleteGooglePayCardTokenArgs = {
  id: Scalars['String']['input'];
  tokenRefId: Scalars['String']['input'];
  walletId: Scalars['String']['input'];
};


export type MutationDeleteInvoiceArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteLegalRepresentativeArgs = {
  id: Scalars['String']['input'];
};


export type MutationDeletePaymentMethodArgs = {
  paymentMethodId: Scalars['String']['input'];
};


export type MutationDeleteQuestionnaireDocumentArgs = {
  questionnaireDocumentId: Scalars['ID']['input'];
};


export type MutationDeleteTaxNumberArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteTransactionAssetArgs = {
  assetId: Scalars['ID']['input'];
};


export type MutationDeleteTransactionSplitsArgs = {
  transactionId: Scalars['ID']['input'];
};


export type MutationDismissBannerArgs = {
  name: BannerName;
};


export type MutationDuplicateInvoiceArgs = {
  id: Scalars['ID']['input'];
};


export type MutationExitBusinessAssetArgs = {
  id: Scalars['ID']['input'];
  payload: ExitBusinessAssetPayload;
};


export type MutationExtractOcrDataArgs = {
  assetId: Scalars['String']['input'];
};


export type MutationFinalizeAssetUploadArgs = {
  assetId: Scalars['ID']['input'];
};


export type MutationFinalizeTaxCaseArgs = {
  shouldFinalizeBusinessTax?: InputMaybe<Scalars['Boolean']['input']>;
  shouldFinalizeIncomeTax?: InputMaybe<Scalars['Boolean']['input']>;
  taxCaseId: Scalars['ID']['input'];
};


export type MutationFinalizeTransactionAssetUploadArgs = {
  assetId: Scalars['ID']['input'];
};


export type MutationGenerateReceiptExportArgs = {
  payload: ReceiptExportInput;
};


export type MutationInitDirectDebitRefundArgs = {
  deliveryMethod: DeliveryMethod;
  deviceId: Scalars['String']['input'];
  transactionId: Scalars['String']['input'];
};


export type MutationMarkViewAsSeenArgs = {
  name: Scalars['String']['input'];
};


export type MutationMatchEmailDocumentToTransactionArgs = {
  emailDocumentId: Scalars['ID']['input'];
  transactionId: Scalars['ID']['input'];
};


export type MutationPostponeQuestionnaireAnswerArgs = {
  questionName: Scalars['String']['input'];
  questionnaireId: Scalars['ID']['input'];
};


export type MutationPreviewBizTaxDeclarationArgs = {
  type: BizTaxDeclarationType;
  year: Scalars['Int']['input'];
};


export type MutationRefundDirectDebitArgs = {
  transactionId: Scalars['String']['input'];
};


export type MutationReorderCardArgs = {
  id: Scalars['String']['input'];
};


export type MutationReplaceCardArgs = {
  id: Scalars['String']['input'];
};


export type MutationRequestCardPushProvisioningArgs = {
  android?: InputMaybe<PushProvisioningAndroidInput>;
  cardId: Scalars['String']['input'];
  deviceId: Scalars['String']['input'];
  ios?: InputMaybe<PushProvisioningIosInput>;
};


export type MutationRequestSubAccountOpeningArgs = {
  requestData: SubAccountOpeningRequest;
};


export type MutationResetDeclarationArgs = {
  period: Scalars['String']['input'];
  year: Scalars['Int']['input'];
};


export type MutationResetLastQuestionnaireAnswerArgs = {
  questionnaireId: Scalars['ID']['input'];
};


export type MutationResetQuestionnaireArgs = {
  questionnaireId: Scalars['ID']['input'];
};


export type MutationSetCardHolderRepresentationArgs = {
  cardHolderRepresentation: Scalars['String']['input'];
};


export type MutationSignPoaArgs = {
  dependents?: InputMaybe<Array<UserDependentInput>>;
  signature: Scalars['String']['input'];
};


export type MutationSignSeizurePaymentOrderArgs = {
  seizureId: Scalars['ID']['input'];
  signature: Scalars['String']['input'];
};


export type MutationSkipIncomeTaxArgs = {
  taxCaseId: Scalars['ID']['input'];
};


export type MutationStartQuestionnaireArgs = {
  questionnaireId?: InputMaybe<Scalars['ID']['input']>;
  type: QuestionnaireType;
  year: Scalars['Int']['input'];
};


export type MutationSubmitBizTaxDeclarationArgs = {
  type: BizTaxDeclarationType;
  year: Scalars['Int']['input'];
};


export type MutationSubmitBookkeepingQuestionnaireArgs = {
  questionnaireId: Scalars['ID']['input'];
};


export type MutationSubmitComplianceQuestionsArgs = {
  input: Array<SubmitComplianceQuestionInput>;
};


export type MutationSubmitDeclarationArgs = {
  period: Scalars['String']['input'];
  year: Scalars['Int']['input'];
};


export type MutationSubmitQuestionSetArgs = {
  input: SubmitQuestionSetInput;
};


export type MutationSubmitQuestionnaireAnswerArgs = {
  questionName: Scalars['String']['input'];
  questionnaireId: Scalars['ID']['input'];
  value?: InputMaybe<Scalars['JSON']['input']>;
};


export type MutationSubscribeToPlanArgs = {
  couponCode?: InputMaybe<Scalars['String']['input']>;
  type: PurchaseType;
};


export type MutationUpdateBeneficialOwnerArgs = {
  data: UpdateBeneficialOwnerInput;
};


export type MutationUpdateBizTaxIsRelevantArgs = {
  isRelevant: Scalars['Boolean']['input'];
  year: Scalars['Int']['input'];
};


export type MutationUpdateBusinessIdentificationArgs = {
  documentsSubmitted?: InputMaybe<Scalars['Boolean']['input']>;
  markAsReady?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationUpdateCardSettingsArgs = {
  id: Scalars['String']['input'];
  settings: CardSettingsInput;
};


export type MutationUpdateClientArgs = {
  client: UpdateClientInput;
};


export type MutationUpdateConsentForDeviceMonitoringArgs = {
  deviceConsentId: Scalars['String']['input'];
  eventType: DeviceConsentEventType;
};


export type MutationUpdateContactArgs = {
  payload: UpdateContactArgs;
};


export type MutationUpdateDeviceBindingRequestArgs = {
  id: Scalars['String']['input'];
  isConfirmation: Scalars['Boolean']['input'];
};


export type MutationUpdateDocumentArgs = {
  id: Scalars['ID']['input'];
  metadata?: InputMaybe<UpdateDocumentMetadata>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type MutationUpdateDraftTransactionArgs = {
  payload: UpdateDraftTransactionInput;
};


export type MutationUpdateExternalTransactionArgs = {
  payload: UserExternalTransactionInput;
};


export type MutationUpdateInvoiceArgs = {
  payload: InvoiceInput;
};


export type MutationUpdateInvoiceCustomerArgs = {
  payload: InvoiceCustomerInput;
};


export type MutationUpdateInvoiceSettingsArgs = {
  payload: InvoiceSettingsInput;
};


export type MutationUpdateLegalRepresentativeArgs = {
  data: CreateLegalRepresentativeInput;
  id: Scalars['String']['input'];
};


export type MutationUpdateOverdraftArgs = {
  offeredScreenShown?: InputMaybe<Scalars['Boolean']['input']>;
  rejectionScreenShown?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationUpdateReviewArgs = {
  reviewId: Scalars['Int']['input'];
  status: UserReviewStatus;
};


export type MutationUpdateSolarisUserArgs = {
  customerType?: InputMaybe<CustomerType>;
  deliveryMethod?: InputMaybe<DeliveryMethod>;
  deviceId: Scalars['String']['input'];
  payload: UpdateSolarisUserInput;
};


export type MutationUpdateSubAccountArgs = {
  requestData: SubAccountUpdateRequest;
};


export type MutationUpdateSubscriptionPlanArgs = {
  couponCode?: InputMaybe<Scalars['String']['input']>;
  newPlan: PurchaseType;
};


export type MutationUpdateTaxNumberArgs = {
  id: Scalars['ID']['input'];
  payload: UpdateTaxNumberInput;
};


export type MutationUpdateTaxYearSettingsArgs = {
  taxYearSettings: Array<TaxYearSettingInput>;
};


export type MutationUpdateTermsAndConditionsArgs = {
  payload: UpdateTermsAndConditionsArgs;
};


export type MutationUpdateTransactionArgs = {
  businessAssetInput?: InputMaybe<BusinessAssetInput>;
  category?: InputMaybe<TransactionCategory>;
  categoryCode?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  personalNote?: InputMaybe<Scalars['String']['input']>;
  splits?: InputMaybe<Array<TransactionSplitInput>>;
  userSelectedBookingDate?: InputMaybe<Scalars['DateTime']['input']>;
  vatCategoryCode?: InputMaybe<Scalars['String']['input']>;
  vatRate?: InputMaybe<VatRate>;
};


export type MutationUpdateTransactionSplitsArgs = {
  splits: Array<UpdateTransactionSplitsInput>;
  transactionId: Scalars['ID']['input'];
};


export type MutationUpdateTransferArgs = {
  deliveryMethod?: InputMaybe<DeliveryMethod>;
  deviceId?: InputMaybe<Scalars['String']['input']>;
  transfer: UpdateTransferInput;
};


export type MutationUpdateUserNotificationsArgs = {
  active: Scalars['Boolean']['input'];
  type: NotificationType;
};


export type MutationUpdateUserSignupInformationArgs = {
  payload: UserUpdateInput;
};


export type MutationUpdateUserTaxDetailsArgs = {
  payload: UserTaxDetailsInput;
};


export type MutationUpdateVatYearSettingArgs = {
  vatPaymentFrequency: PaymentFrequency;
  year: Scalars['Int']['input'];
};


export type MutationUpsertBusinessArgs = {
  data: BusinessInput;
};


export type MutationUpsertDeclarationArgs = {
  payload: UpsertDeclarationArgs;
};


export type MutationUpsertProductsArgs = {
  payload: Array<UserProductInput>;
};


export type MutationUpsertQuestionnaireDocumentArgs = {
  payload: QuestionnaireDocumentInput;
  questionnaireId: Scalars['ID']['input'];
};


export type MutationUpsertUserTourArgs = {
  payload: UpsertUserTourInput;
};


export type MutationUserConfirmationArgs = {
  confirmation: UserConfirmation;
  year?: InputMaybe<Scalars['Int']['input']>;
};


export type MutationVirtualCardDetailsArgs = {
  args: VirtualCardDetailsArgs;
  id: Scalars['String']['input'];
};

export type MutationResult = {
  __typename?: 'MutationResult';
  success: Scalars['Boolean']['output'];
};

/** NACE codes */
export type NaceCode = {
  __typename?: 'NACECode';
  code: Scalars['String']['output'];
  deDescription: Scalars['String']['output'];
  enDescription: Scalars['String']['output'];
  id: Scalars['Float']['output'];
  priority: Scalars['Boolean']['output'];
};

export type NaceCodeQueryArgs = {
  description?: InputMaybe<Scalars['String']['input']>;
  level4Code?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum Nationality {
  Ad = 'AD',
  Ae = 'AE',
  Af = 'AF',
  Ag = 'AG',
  Ai = 'AI',
  Al = 'AL',
  Am = 'AM',
  Ao = 'AO',
  Aq = 'AQ',
  Ar = 'AR',
  As = 'AS',
  At = 'AT',
  Au = 'AU',
  Aw = 'AW',
  Ax = 'AX',
  Az = 'AZ',
  Ba = 'BA',
  Bb = 'BB',
  Bd = 'BD',
  Be = 'BE',
  Bf = 'BF',
  Bg = 'BG',
  Bh = 'BH',
  Bi = 'BI',
  Bj = 'BJ',
  Bl = 'BL',
  Bm = 'BM',
  Bn = 'BN',
  Bo = 'BO',
  Br = 'BR',
  Bs = 'BS',
  Bt = 'BT',
  Bv = 'BV',
  Bw = 'BW',
  By = 'BY',
  Bz = 'BZ',
  Ca = 'CA',
  Cc = 'CC',
  Cd = 'CD',
  Cf = 'CF',
  Cg = 'CG',
  Ch = 'CH',
  Ci = 'CI',
  Ck = 'CK',
  Cl = 'CL',
  Cm = 'CM',
  Cn = 'CN',
  Co = 'CO',
  Cr = 'CR',
  Cu = 'CU',
  Cv = 'CV',
  Cw = 'CW',
  Cx = 'CX',
  Cy = 'CY',
  Cz = 'CZ',
  De = 'DE',
  Dj = 'DJ',
  Dk = 'DK',
  Dm = 'DM',
  Do = 'DO',
  Dz = 'DZ',
  Ec = 'EC',
  Ee = 'EE',
  Eg = 'EG',
  Eh = 'EH',
  Er = 'ER',
  Es = 'ES',
  Et = 'ET',
  Fi = 'FI',
  Fj = 'FJ',
  Fk = 'FK',
  Fm = 'FM',
  Fo = 'FO',
  Fr = 'FR',
  Ga = 'GA',
  Gb = 'GB',
  Gd = 'GD',
  Ge = 'GE',
  Gf = 'GF',
  Gg = 'GG',
  Gh = 'GH',
  Gi = 'GI',
  Gl = 'GL',
  Gm = 'GM',
  Gn = 'GN',
  Gp = 'GP',
  Gq = 'GQ',
  Gr = 'GR',
  Gs = 'GS',
  Gt = 'GT',
  Gu = 'GU',
  Gw = 'GW',
  Gy = 'GY',
  Hk = 'HK',
  Hm = 'HM',
  Hn = 'HN',
  Hr = 'HR',
  Ht = 'HT',
  Hu = 'HU',
  Id = 'ID',
  Ie = 'IE',
  Il = 'IL',
  Im = 'IM',
  In = 'IN',
  Io = 'IO',
  Iq = 'IQ',
  Ir = 'IR',
  Is = 'IS',
  It = 'IT',
  Je = 'JE',
  Jm = 'JM',
  Jo = 'JO',
  Jp = 'JP',
  Ke = 'KE',
  Kg = 'KG',
  Kh = 'KH',
  Ki = 'KI',
  Km = 'KM',
  Kn = 'KN',
  Kp = 'KP',
  Kr = 'KR',
  Kw = 'KW',
  Ky = 'KY',
  Kz = 'KZ',
  La = 'LA',
  Lb = 'LB',
  Lc = 'LC',
  Li = 'LI',
  Lk = 'LK',
  Lr = 'LR',
  Ls = 'LS',
  Lt = 'LT',
  Lu = 'LU',
  Lv = 'LV',
  Ly = 'LY',
  Ma = 'MA',
  Mc = 'MC',
  Md = 'MD',
  Me = 'ME',
  Mf = 'MF',
  Mg = 'MG',
  Mh = 'MH',
  Mk = 'MK',
  Ml = 'ML',
  Mm = 'MM',
  Mn = 'MN',
  Mo = 'MO',
  Mp = 'MP',
  Mq = 'MQ',
  Mr = 'MR',
  Ms = 'MS',
  Mt = 'MT',
  Mu = 'MU',
  Mv = 'MV',
  Mw = 'MW',
  Mx = 'MX',
  My = 'MY',
  Mz = 'MZ',
  Na = 'NA',
  Nc = 'NC',
  Ne = 'NE',
  Nf = 'NF',
  Ng = 'NG',
  Ni = 'NI',
  Nl = 'NL',
  No = 'NO',
  Np = 'NP',
  Nr = 'NR',
  Nu = 'NU',
  Nz = 'NZ',
  Om = 'OM',
  Pa = 'PA',
  Pe = 'PE',
  Pf = 'PF',
  Pg = 'PG',
  Ph = 'PH',
  Pk = 'PK',
  Pl = 'PL',
  Pm = 'PM',
  Pn = 'PN',
  Pr = 'PR',
  Ps = 'PS',
  Pt = 'PT',
  Pw = 'PW',
  Py = 'PY',
  Qa = 'QA',
  Re = 'RE',
  Ro = 'RO',
  Rs = 'RS',
  Ru = 'RU',
  Rw = 'RW',
  Sa = 'SA',
  Sb = 'SB',
  Sc = 'SC',
  Sd = 'SD',
  Se = 'SE',
  Sg = 'SG',
  Si = 'SI',
  Sj = 'SJ',
  Sk = 'SK',
  Sl = 'SL',
  Sm = 'SM',
  Sn = 'SN',
  So = 'SO',
  Sr = 'SR',
  Ss = 'SS',
  St = 'ST',
  Sv = 'SV',
  Sx = 'SX',
  Sy = 'SY',
  Sz = 'SZ',
  Tc = 'TC',
  Td = 'TD',
  Tf = 'TF',
  Tg = 'TG',
  Th = 'TH',
  Tj = 'TJ',
  Tk = 'TK',
  Tl = 'TL',
  Tm = 'TM',
  Tn = 'TN',
  To = 'TO',
  Tr = 'TR',
  Tt = 'TT',
  Tv = 'TV',
  Tw = 'TW',
  Tz = 'TZ',
  Ua = 'UA',
  Ug = 'UG',
  Um = 'UM',
  Us = 'US',
  Uy = 'UY',
  Uz = 'UZ',
  Va = 'VA',
  Vc = 'VC',
  Ve = 'VE',
  Vg = 'VG',
  Vi = 'VI',
  Vn = 'VN',
  Vu = 'VU',
  Wf = 'WF',
  Ws = 'WS',
  Xk = 'XK',
  Ye = 'YE',
  Yt = 'YT',
  Za = 'ZA',
  Zm = 'ZM',
  Zw = 'ZW'
}

export type Notification = {
  __typename?: 'Notification';
  active: Scalars['Boolean']['output'];
  type: NotificationType;
};

export enum NotificationType {
  All = 'ALL',
  AtmWithdrawalTransactions = 'ATM_WITHDRAWAL_TRANSACTIONS',
  CardTransactions = 'CARD_TRANSACTIONS',
  DirectDebitTransactions = 'DIRECT_DEBIT_TRANSACTIONS',
  IncomingTransactions = 'INCOMING_TRANSACTIONS',
  ProductInfo = 'PRODUCT_INFO',
  ReceiptScanning = 'RECEIPT_SCANNING',
  Statements = 'STATEMENTS',
  Tax = 'TAX',
  Transactions = 'TRANSACTIONS'
}

export type OcrResult = {
  __typename?: 'OCRResult';
  amount?: Maybe<Scalars['Int']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  iban?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

export type Overdraft = {
  __typename?: 'Overdraft';
  id: Scalars['String']['output'];
  /** Available overdraft limit */
  limit?: Maybe<Scalars['Int']['output']>;
  /** Indicates if offered screen for overdraft was shown */
  offeredScreenShown: Scalars['Boolean']['output'];
  /** Indicates if rejection screen for overdraft was shown */
  rejectionScreenShown: Scalars['Boolean']['output'];
  /** Overdraft request date */
  requestedAt: Scalars['DateTime']['output'];
  /** Overdraft status */
  status: OverdraftApplicationStatus;
};

export enum OverdraftApplicationStatus {
  AccountSnapshotPending = 'ACCOUNT_SNAPSHOT_PENDING',
  AccountSnapshotVerificationPending = 'ACCOUNT_SNAPSHOT_VERIFICATION_PENDING',
  Created = 'CREATED',
  Expired = 'EXPIRED',
  InitialScoringPending = 'INITIAL_SCORING_PENDING',
  Offered = 'OFFERED',
  OverdraftCreated = 'OVERDRAFT_CREATED',
  Rejected = 'REJECTED'
}

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['String']['output']>;
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  startCursor?: Maybe<Scalars['String']['output']>;
};

export enum PaymentFrequency {
  Monthly = 'MONTHLY',
  None = 'NONE',
  NoneQuarterly = 'NONE_QUARTERLY',
  Quarterly = 'QUARTERLY',
  Yearly = 'YEARLY'
}

export type PaymentMethod = {
  __typename?: 'PaymentMethod';
  cardBrand: Scalars['String']['output'];
  cardLast4: Scalars['String']['output'];
  paymentMethodId: Scalars['String']['output'];
};

export type PendingTransactionVerification = {
  __typename?: 'PendingTransactionVerification';
  /** Transaction amount */
  amount: Scalars['String']['output'];
  /** Change request id to authenticate verification */
  authenticateChangeRequestId: Scalars['String']['output'];
  /** Change request id to decline verification */
  declineChangeRequestId: Scalars['String']['output'];
  /** When verification gets expired */
  expiresAt: Scalars['String']['output'];
  /** Transaction merchant name */
  name: Scalars['String']['output'];
};

export type Period = {
  __typename?: 'Period';
  month: Scalars['Int']['output'];
  year: Scalars['Int']['output'];
};

export enum PermanentExtensionStatus {
  DoesHave = 'DOES_HAVE',
  DoesNotHave = 'DOES_NOT_HAVE',
  DoesNotKnow = 'DOES_NOT_KNOW'
}

export enum Platform {
  Android = 'ANDROID',
  Ios = 'IOS',
  Web = 'WEB'
}

export type Product = {
  __typename?: 'Product';
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  price?: Maybe<Scalars['Float']['output']>;
  vat?: Maybe<Scalars['String']['output']>;
};

export type PublicMutationResult = {
  __typename?: 'PublicMutationResult';
  success: Scalars['Boolean']['output'];
};

export enum PurchaseState {
  Pending = 'PENDING',
  Processed = 'PROCESSED'
}

export enum PurchaseType {
  Basic = 'BASIC',
  BasicInitial = 'BASIC_INITIAL',
  BizTax = 'BIZ_TAX',
  Bookkeeping = 'BOOKKEEPING',
  Card = 'CARD',
  Free = 'FREE',
  FreeCard = 'FREE_CARD',
  Kontax = 'KONTAX',
  KontaxPending = 'KONTAX_PENDING',
  KontaxSb = 'KONTAX_SB',
  Lexoffice = 'LEXOFFICE',
  Plus = 'PLUS',
  Premium = 'PREMIUM',
  Start = 'START',
  VirtualCard = 'VIRTUAL_CARD'
}

export type PushProvisioningAndroidInput = {
  /** Stable identifier for a physical Android device Google refers to this atribute as a Stable hardware ID in their SDK documentation the method getStableHardwareId describes how you can retrieve this value. */
  deviceId?: InputMaybe<Scalars['String']['input']>;
  /** Unique 24-byte identifier for each instance of a [Android user, Google account] pair wallet. ID is computed as a keyed hash of the Android user ID and the Google account ID. The key to this hash lives on Google servers, meaning the wallet ID is created during user setup as an RPC. */
  walletAccountId?: InputMaybe<Scalars['String']['input']>;
};

export type PushProvisioningIosInput = {
  /** An array of leaf and sub-CA certificates in Base64 encoded format provided by Apple. Each object contains a DER encoded X.509 certificate, with the leaf first and followed by sub-CA */
  certificates?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A one-time-use nonce in Base64 encoded format provided by Apple */
  nonce?: InputMaybe<Scalars['String']['input']>;
  /** Nonce signature in Base64 encoded format provided by Apple */
  nonceSignature?: InputMaybe<Scalars['String']['input']>;
};

export type PushProvisioningOutput = {
  __typename?: 'PushProvisioningOutput';
  activationData?: Maybe<Scalars['String']['output']>;
  encryptedPassData?: Maybe<Scalars['String']['output']>;
  ephemeralPublicKey?: Maybe<Scalars['String']['output']>;
  walletPayload?: Maybe<Scalars['String']['output']>;
};

export type Query = {
  __typename?: 'Query';
  BWASummary: BwaSummary;
  contacts: Array<Contact>;
  /** Get all existing DATEV Exports requested by the user */
  datevExports: Array<DatevExport>;
  draftTransactions: Array<DraftTransaction>;
  /** Get all released generic features, that are needed before user creation */
  genericFeatures: Array<GenericFeature>;
  getBeneficialOwner: BeneficialOwner;
  getCompanyDetails?: Maybe<CompanyDetails>;
  /** Get device binding request */
  getDeviceBindingRequest?: Maybe<DeviceBindingRequest>;
  /** Get bank information for IBAN */
  getIBANInformation: IbanInformation;
  /** Get all existing receipt exports requested by the user */
  getReceiptExports: Array<ReceiptExport>;
  getSignupState?: Maybe<SignupState>;
  getSubAccounts: Array<SubAccount>;
  getSuggestedCompanies: Array<CompanySuggestion>;
  /** Determines if user device has restricted key added */
  hasDeviceRestrictedKey: Scalars['Boolean']['output'];
  insightsV2: Array<AccountInsight>;
  listBeneficialOwners: Array<BeneficialOwner>;
  /** Returns list of bound devices */
  listBoundDevices: Array<BoundDevice>;
  listLegalRepresentatives: Array<LegalRepresentative>;
  listPaymentMethods: Array<PaymentMethod>;
  municipalities: Array<Municipality>;
  naceCodes: Array<NaceCode>;
  registration?: Maybe<Array<SearchResult>>;
  registrationDetails?: Maybe<FindResult>;
  status: SystemStatus;
  suggestion?: Maybe<Array<FindResult>>;
  termsAndConditions?: Maybe<Array<TermsAndConditions>>;
  transactions: TransactionsConnection;
  /** The current user information */
  viewer?: Maybe<User>;
};


export type QueryBwaSummaryArgs = {
  year: Scalars['Int']['input'];
};


export type QueryContactsArgs = {
  filter?: InputMaybe<Scalars['String']['input']>;
};


export type QueryGetBeneficialOwnerArgs = {
  id: Scalars['String']['input'];
};


export type QueryGetCompanyDetailsArgs = {
  registrationIssuer: Scalars['String']['input'];
  registrationNumber: Scalars['String']['input'];
};


export type QueryGetDeviceBindingRequestArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};


export type QueryGetIbanInformationArgs = {
  iban: Scalars['String']['input'];
};


export type QueryGetSuggestedCompaniesArgs = {
  name: Scalars['String']['input'];
};


export type QueryHasDeviceRestrictedKeyArgs = {
  deviceId: Scalars['String']['input'];
};


export type QueryInsightsV2Args = {
  endDate: Scalars['String']['input'];
  startDate: Scalars['String']['input'];
};


export type QueryMunicipalitiesArgs = {
  searchTerm?: InputMaybe<Scalars['String']['input']>;
};


export type QueryNaceCodesArgs = {
  payload?: InputMaybe<NaceCodeQueryArgs>;
};


export type QueryRegistrationArgs = {
  country?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};


export type QueryRegistrationDetailsArgs = {
  country?: InputMaybe<Scalars['String']['input']>;
  registrationIssuer: Scalars['String']['input'];
  registrationNumber: Scalars['String']['input'];
};


export type QuerySuggestionArgs = {
  country?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Float']['input']>;
  name: Scalars['String']['input'];
};


export type QueryTermsAndConditionsArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<TransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  publicId?: InputMaybe<Scalars['String']['input']>;
};

export type Question = {
  __typename?: 'Question';
  answerType: AnswerType;
  documentType?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  question: Scalars['String']['output'];
};

export type QuestionAnswer = {
  answer: Scalars['String']['input'];
  documentIds?: InputMaybe<Array<Scalars['String']['input']>>;
  questionId: Scalars['String']['input'];
};

export type QuestionSet = {
  __typename?: 'QuestionSet';
  deadline?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  questions: Array<Question>;
};

export type Questionnaire = {
  __typename?: 'Questionnaire';
  answers: Array<QuestionnaireAnswer>;
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  context?: Maybe<Scalars['JSON']['output']>;
  documents: Array<QuestionnaireDocument>;
  id: Scalars['ID']['output'];
  lastAnswer?: Maybe<QuestionnaireAnswer>;
  nextQuestion?: Maybe<QuestionnaireQuestion>;
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  status: QuestionnaireStatus;
  syncedAt?: Maybe<Scalars['DateTime']['output']>;
  type: QuestionnaireType;
  year: Scalars['Int']['output'];
};


export type QuestionnaireAnswersArgs = {
  questionNames?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QuestionnaireNextQuestionArgs = {
  includePostponed?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuestionnaireAnswer = {
  __typename?: 'QuestionnaireAnswer';
  documentsStatus: QuestionnaireAnswerDocumentsStatus;
  postponedAt?: Maybe<Scalars['DateTime']['output']>;
  questionName: Scalars['String']['output'];
  submittedAt?: Maybe<Scalars['DateTime']['output']>;
  syncedAt?: Maybe<Scalars['DateTime']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  value?: Maybe<Scalars['JSON']['output']>;
};

export enum QuestionnaireAnswerDocumentsStatus {
  Deleted = 'DELETED',
  NotRequired = 'NOT_REQUIRED',
  Pending = 'PENDING',
  Uploaded = 'UPLOADED'
}

export type QuestionnaireDocument = {
  __typename?: 'QuestionnaireDocument';
  assets: Array<Asset>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  inputs?: Maybe<Scalars['JSON']['output']>;
  isLastYearSuggestion: Scalars['Boolean']['output'];
  syncedAt?: Maybe<Scalars['DateTime']['output']>;
  type: QuestionnaireDocumentType;
  updatedAt: Scalars['DateTime']['output'];
};

export type QuestionnaireDocumentInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  inputs: Scalars['JSONObject']['input'];
  type: QuestionnaireDocumentType;
};

export enum QuestionnaireDocumentType {
  BizTaxCarUsageLogbook = 'BIZ_TAX_CAR_USAGE_LOGBOOK',
  BizTaxCarUsagePurchaseContract = 'BIZ_TAX_CAR_USAGE_PURCHASE_CONTRACT',
  BizTaxCarUsageTraveledKmWithPrivateCar = 'BIZ_TAX_CAR_USAGE_TRAVELED_KM_WITH_PRIVATE_CAR',
  BizTaxOfficeUsageElectricity = 'BIZ_TAX_OFFICE_USAGE_ELECTRICITY',
  BizTaxOfficeUsageFloorPlan = 'BIZ_TAX_OFFICE_USAGE_FLOOR_PLAN',
  BizTaxOfficeUsageHeating = 'BIZ_TAX_OFFICE_USAGE_HEATING',
  BizTaxOfficeUsageOther = 'BIZ_TAX_OFFICE_USAGE_OTHER',
  BizTaxOfficeUsagePhoneOrInternet = 'BIZ_TAX_OFFICE_USAGE_PHONE_OR_INTERNET',
  BizTaxOfficeUsageRentOrInterest = 'BIZ_TAX_OFFICE_USAGE_RENT_OR_INTEREST',
  BizTaxOfficeUsageUtility = 'BIZ_TAX_OFFICE_USAGE_UTILITY',
  BizTaxOfficeUsageUtilityAfterPayment = 'BIZ_TAX_OFFICE_USAGE_UTILITY_AFTER_PAYMENT',
  BizTaxTravelExpensesBusinessTrips = 'BIZ_TAX_TRAVEL_EXPENSES_BUSINESS_TRIPS',
  EoyCarUsageLogbook = 'EOY_CAR_USAGE_LOGBOOK',
  EoyCarUsageOther = 'EOY_CAR_USAGE_OTHER',
  EoyCarUsagePrivatelyPaidCarExpenses = 'EOY_CAR_USAGE_PRIVATELY_PAID_CAR_EXPENSES',
  EoyCarUsagePurchaseContract = 'EOY_CAR_USAGE_PURCHASE_CONTRACT',
  EoyCarUsageTraveledKmWithPrivateCar = 'EOY_CAR_USAGE_TRAVELED_KM_WITH_PRIVATE_CAR',
  EoyIncomeTaxAdditionalIncomeAddlSelfEmployment = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_ADDL_SELF_EMPLOYMENT',
  EoyIncomeTaxAdditionalIncomeCapitalAssetsIntl = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_CAPITAL_ASSETS_INTL',
  EoyIncomeTaxAdditionalIncomeCrypto = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_CRYPTO',
  EoyIncomeTaxAdditionalIncomeEmployedWork = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_EMPLOYED_WORK',
  EoyIncomeTaxAdditionalIncomeEmploymentExpenses = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_EMPLOYMENT_EXPENSES',
  EoyIncomeTaxAdditionalIncomeInternationalIncome = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_INTERNATIONAL_INCOME',
  EoyIncomeTaxAdditionalIncomeOther = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_OTHER',
  EoyIncomeTaxAdditionalIncomePartnerAddlSelfEmployment = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_PARTNER_ADDL_SELF_EMPLOYMENT',
  EoyIncomeTaxAdditionalIncomePartnerCapitalAssetsIntl = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_PARTNER_CAPITAL_ASSETS_INTL',
  EoyIncomeTaxAdditionalIncomePartnerCrypto = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_PARTNER_CRYPTO',
  EoyIncomeTaxAdditionalIncomePartnerEmployedWork = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_PARTNER_EMPLOYED_WORK',
  EoyIncomeTaxAdditionalIncomePartnerEmploymentExpenses = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_PARTNER_EMPLOYMENT_EXPENSES',
  EoyIncomeTaxAdditionalIncomePartnerInternationalIncome = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_PARTNER_INTERNATIONAL_INCOME',
  EoyIncomeTaxAdditionalIncomePartnerOther = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_PARTNER_OTHER',
  EoyIncomeTaxAdditionalIncomePartnerPensions = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_PARTNER_PENSIONS',
  EoyIncomeTaxAdditionalIncomePartnerSaleOfProperty = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_PARTNER_SALE_OF_PROPERTY',
  EoyIncomeTaxAdditionalIncomePensions = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_PENSIONS',
  EoyIncomeTaxAdditionalIncomeSaleOfProperty = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_SALE_OF_PROPERTY',
  EoyIncomeTaxBasicDataOther = 'EOY_INCOME_TAX_BASIC_DATA_OTHER',
  EoyIncomeTaxBasicDataPartnerOther = 'EOY_INCOME_TAX_BASIC_DATA_PARTNER_OTHER',
  EoyIncomeTaxBasicDataPartnerProofOfDisability = 'EOY_INCOME_TAX_BASIC_DATA_PARTNER_PROOF_OF_DISABILITY',
  EoyIncomeTaxBasicDataProofOfDisability = 'EOY_INCOME_TAX_BASIC_DATA_PROOF_OF_DISABILITY',
  EoyIncomeTaxBasicDataRentalAndLease = 'EOY_INCOME_TAX_BASIC_DATA_RENTAL_AND_LEASE',
  EoyIncomeTaxChildAdditionalHealthInsurance = 'EOY_INCOME_TAX_CHILD_ADDITIONAL_HEALTH_INSURANCE',
  EoyIncomeTaxChildChildcare = 'EOY_INCOME_TAX_CHILD_CHILDCARE',
  EoyIncomeTaxChildDisabilityCosts = 'EOY_INCOME_TAX_CHILD_DISABILITY_COSTS',
  EoyIncomeTaxChildExtensiveMedicalExpenses = 'EOY_INCOME_TAX_CHILD_EXTENSIVE_MEDICAL_EXPENSES',
  EoyIncomeTaxChildOther = 'EOY_INCOME_TAX_CHILD_OTHER',
  EoyIncomeTaxChildProofOfDisability = 'EOY_INCOME_TAX_CHILD_PROOF_OF_DISABILITY',
  EoyIncomeTaxChildSchoolFees = 'EOY_INCOME_TAX_CHILD_SCHOOL_FEES',
  EoyIncomeTaxChildUniversityFees = 'EOY_INCOME_TAX_CHILD_UNIVERSITY_FEES',
  EoyIncomeTaxPrivateExpensesAccidentInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_ACCIDENT_INSURANCE',
  EoyIncomeTaxPrivateExpensesAliments = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_ALIMENTS',
  EoyIncomeTaxPrivateExpensesDisabilityInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_DISABILITY_INSURANCE',
  EoyIncomeTaxPrivateExpensesExtraordinaryBurdens = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_EXTRAORDINARY_BURDENS',
  EoyIncomeTaxPrivateExpensesHealthInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_HEALTH_INSURANCE',
  EoyIncomeTaxPrivateExpensesHouseholdServices = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_HOUSEHOLD_SERVICES',
  EoyIncomeTaxPrivateExpensesLifeInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_LIFE_INSURANCE',
  EoyIncomeTaxPrivateExpensesOther = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_OTHER',
  EoyIncomeTaxPrivateExpensesPartnerAccidentInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_ACCIDENT_INSURANCE',
  EoyIncomeTaxPrivateExpensesPartnerAliments = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_ALIMENTS',
  EoyIncomeTaxPrivateExpensesPartnerDisabilityInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_DISABILITY_INSURANCE',
  EoyIncomeTaxPrivateExpensesPartnerExtraordinaryBurdens = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_EXTRAORDINARY_BURDENS',
  EoyIncomeTaxPrivateExpensesPartnerHealthInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_HEALTH_INSURANCE',
  EoyIncomeTaxPrivateExpensesPartnerHouseholdServices = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_HOUSEHOLD_SERVICES',
  EoyIncomeTaxPrivateExpensesPartnerLifeInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_LIFE_INSURANCE',
  EoyIncomeTaxPrivateExpensesPartnerOther = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_OTHER',
  EoyIncomeTaxPrivateExpensesPartnerPensionInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_PENSION_INSURANCE',
  EoyIncomeTaxPrivateExpensesPartnerPrivateDonations = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_PRIVATE_DONATIONS',
  EoyIncomeTaxPrivateExpensesPartnerReister = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_REISTER',
  EoyIncomeTaxPrivateExpensesPartnerRurup = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_RURUP',
  EoyIncomeTaxPrivateExpensesPartnerUnemploymentInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_UNEMPLOYMENT_INSURANCE',
  EoyIncomeTaxPrivateExpensesPartnerUniversityFees = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_UNIVERSITY_FEES',
  EoyIncomeTaxPrivateExpensesPartnerVehicleLiability = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER_VEHICLE_LIABILITY',
  EoyIncomeTaxPrivateExpensesPensionInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PENSION_INSURANCE',
  EoyIncomeTaxPrivateExpensesPrivateDonations = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PRIVATE_DONATIONS',
  EoyIncomeTaxPrivateExpensesReister = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_REISTER',
  EoyIncomeTaxPrivateExpensesRurup = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_RURUP',
  EoyIncomeTaxPrivateExpensesUnemploymentInsurance = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_UNEMPLOYMENT_INSURANCE',
  EoyIncomeTaxPrivateExpensesUniversityFees = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_UNIVERSITY_FEES',
  EoyIncomeTaxPrivateExpensesVehicleLiability = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_VEHICLE_LIABILITY',
  EoyOfficeUsageElectricity = 'EOY_OFFICE_USAGE_ELECTRICITY',
  EoyOfficeUsageFloorPlan = 'EOY_OFFICE_USAGE_FLOOR_PLAN',
  EoyOfficeUsageHeating = 'EOY_OFFICE_USAGE_HEATING',
  EoyOfficeUsageOther = 'EOY_OFFICE_USAGE_OTHER',
  EoyOfficeUsagePhoneOrInternet = 'EOY_OFFICE_USAGE_PHONE_OR_INTERNET',
  EoyOfficeUsageRentOrInterest = 'EOY_OFFICE_USAGE_RENT_OR_INTEREST',
  EoyOfficeUsageUtility = 'EOY_OFFICE_USAGE_UTILITY',
  EoyOfficeUsageUtilityAfterPayment = 'EOY_OFFICE_USAGE_UTILITY_AFTER_PAYMENT',
  EoyTravelExpensesBusinessTrips = 'EOY_TRAVEL_EXPENSES_BUSINESS_TRIPS',
  EoyTravelExpensesOther = 'EOY_TRAVEL_EXPENSES_OTHER'
}

export type QuestionnaireQuestion = {
  __typename?: 'QuestionnaireQuestion';
  allowExit?: Maybe<Scalars['Boolean']['output']>;
  defaultAnswer?: Maybe<Scalars['JSON']['output']>;
  inputConfig?: Maybe<Scalars['JSONObject']['output']>;
  lastYearAnswer?: Maybe<QuestionnaireAnswer>;
  name: Scalars['String']['output'];
  postponable?: Maybe<Scalars['Boolean']['output']>;
  previousQuestionsAnswers?: Maybe<Array<QuestionnaireAnswer>>;
  suggestLastYearAnswer?: Maybe<Scalars['Boolean']['output']>;
  topic?: Maybe<Scalars['String']['output']>;
};

export enum QuestionnaireStatus {
  Completed = 'COMPLETED',
  DocumentsUploaded = 'DOCUMENTS_UPLOADED',
  NotStarted = 'NOT_STARTED',
  Started = 'STARTED'
}

export type QuestionnaireTask = {
  __typename?: 'QuestionnaireTask';
  status: QuestionnaireTaskStatus;
  type: QuestionnaireType;
  year: Scalars['Int']['output'];
};

export enum QuestionnaireTaskStatus {
  Completed = 'COMPLETED',
  InProgress = 'IN_PROGRESS',
  InReview = 'IN_REVIEW',
  ToDo = 'TO_DO'
}

export enum QuestionnaireType {
  BizTaxBasicData = 'BIZ_TAX_BASIC_DATA',
  BizTaxCarUsage = 'BIZ_TAX_CAR_USAGE',
  BizTaxOfficeUsage = 'BIZ_TAX_OFFICE_USAGE',
  BizTaxTravelExpenses = 'BIZ_TAX_TRAVEL_EXPENSES',
  EoyBasicData = 'EOY_BASIC_DATA',
  EoyBookkeeping = 'EOY_BOOKKEEPING',
  EoyCarUsage = 'EOY_CAR_USAGE',
  EoyIncomeTax = 'EOY_INCOME_TAX',
  EoyIncomeTaxAdditionalIncome = 'EOY_INCOME_TAX_ADDITIONAL_INCOME',
  EoyIncomeTaxAdditionalIncomePartner = 'EOY_INCOME_TAX_ADDITIONAL_INCOME_PARTNER',
  EoyIncomeTaxBasicData = 'EOY_INCOME_TAX_BASIC_DATA',
  EoyIncomeTaxBasicDataPartner = 'EOY_INCOME_TAX_BASIC_DATA_PARTNER',
  EoyIncomeTaxChild = 'EOY_INCOME_TAX_CHILD',
  EoyIncomeTaxPrivateExpenses = 'EOY_INCOME_TAX_PRIVATE_EXPENSES',
  EoyIncomeTaxPrivateExpensesPartner = 'EOY_INCOME_TAX_PRIVATE_EXPENSES_PARTNER',
  EoyOfficeUsage = 'EOY_OFFICE_USAGE',
  EoyTravelExpenses = 'EOY_TRAVEL_EXPENSES',
  StartOfTheYear = 'START_OF_THE_YEAR'
}

export type RawTransactionProjection = {
  __typename?: 'RawTransactionProjection';
  actionReason?: Maybe<ActionReason>;
  /** The amount of the transaction in cents */
  amount: Scalars['Int']['output'];
  /** View a single Asset for a transaction */
  asset?: Maybe<TransactionAsset>;
  /** List of uploaded Asset files for this transaction */
  assets: Array<TransactionAsset>;
  /** The date at which the transaction was booked (created) */
  bookingDate: Scalars['DateTime']['output'];
  /** View a single Business Asset for a transaction */
  businessAsset?: Maybe<BusinessAssetResponse>;
  canBeRecategorized: Scalars['Boolean']['output'];
  categorizationType?: Maybe<CategorizationType>;
  category?: Maybe<TransactionCategory>;
  categoryCode?: Maybe<Scalars['String']['output']>;
  categoryCodeTranslation?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  directDebitFees: Array<DirectDebitFee>;
  documentDownloadUrl?: Maybe<Scalars['String']['output']>;
  documentNumber?: Maybe<Scalars['String']['output']>;
  documentPreviewUrl?: Maybe<Scalars['String']['output']>;
  documentType?: Maybe<DocumentType>;
  e2eId?: Maybe<Scalars['String']['output']>;
  fees: Array<TransactionFee>;
  foreignCurrency?: Maybe<Scalars['String']['output']>;
  hasAssets: Scalars['Boolean']['output'];
  iban?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  mandateNumber?: Maybe<Scalars['String']['output']>;
  merchantCategoryCode?: Maybe<Scalars['String']['output']>;
  merchantCountryCode?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  originalAmount?: Maybe<Scalars['Float']['output']>;
  paymentMethod: Scalars['String']['output'];
  personalNote?: Maybe<Scalars['String']['output']>;
  predictedCategory?: Maybe<TransactionCategory>;
  /** Date predicted for tax/vat payment/refund predicted category */
  predictedUserSelectedBookingDate?: Maybe<Scalars['DateTime']['output']>;
  purpose?: Maybe<Scalars['String']['output']>;
  receiptName?: Maybe<Scalars['String']['output']>;
  recurlyInvoiceNumber?: Maybe<Scalars['String']['output']>;
  source: TransactionSource;
  /** Metadata of separate pseudo-transactions created when splitting the parent transaction */
  splits: Array<TransactionSplit>;
  /** View a single Asset for a transaction */
  transactionAsset?: Maybe<Asset>;
  /** List Assets for a transaction */
  transactionAssets: Array<Asset>;
  type: TransactionProjectionType;
  /** When a transaction corresponds to a tax or vat payment, the user may specify at which date it should be considered booked */
  userSelectedBookingDate?: Maybe<Scalars['DateTime']['output']>;
  /** The date at which the transaction was processed and the amount deducted from the user's account */
  valutaDate?: Maybe<Scalars['DateTime']['output']>;
  vatCategoryCode?: Maybe<Scalars['String']['output']>;
  vatRate?: Maybe<VatRate>;
  verified?: Maybe<Scalars['Boolean']['output']>;
};


export type RawTransactionProjectionAssetArgs = {
  assetId: Scalars['ID']['input'];
};


export type RawTransactionProjectionTransactionAssetArgs = {
  assetId: Scalars['ID']['input'];
};

export type ReceiptExport = {
  __typename?: 'ReceiptExport';
  creationDate: Scalars['DateTime']['output'];
  expirationDate: Scalars['DateTime']['output'];
  filename: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type ReceiptExportInput = {
  fromDate: Scalars['DateTime']['input'];
  toDate: Scalars['DateTime']['input'];
};

export type ReceiptExportResult = {
  __typename?: 'ReceiptExportResult';
  count: Scalars['Int']['output'];
};

export type RecurlyAccount = {
  __typename?: 'RecurlyAccount';
  accountManagementUrl: Scalars['String']['output'];
  balance: Scalars['Float']['output'];
  pastDue: Scalars['Boolean']['output'];
  pastDueSince?: Maybe<Scalars['DateTime']['output']>;
  recurlyAccountId: Scalars['String']['output'];
};

export type RecurlyInvoice = {
  __typename?: 'RecurlyInvoice';
  id: Scalars['ID']['output'];
  recurlyCreatedAt?: Maybe<Scalars['DateTime']['output']>;
  url: Scalars['String']['output'];
};

export type ReferralDetails = {
  __typename?: 'ReferralDetails';
  /** Amount in euros granted to user and their referee */
  bonusAmount: Scalars['Int']['output'];
  code?: Maybe<Scalars['String']['output']>;
  copy: Scalars['String']['output'];
  link?: Maybe<Scalars['String']['output']>;
};

export enum RequestPlatform {
  Backend = 'BACKEND',
  Backoffice = 'BACKOFFICE',
  Email = 'EMAIL',
  Giovanni = 'GIOVANNI',
  Invoicing = 'INVOICING',
  Mobile = 'MOBILE',
  NativeShare = 'NATIVE_SHARE',
  Web = 'WEB'
}

export enum ReviewTriggerName {
  BatchTransfers = 'BATCH_TRANSFERS',
  Googlepay = 'GOOGLEPAY',
  OutgoingTransactions = 'OUTGOING_TRANSACTIONS',
  OverdraftOffered = 'OVERDRAFT_OFFERED',
  PhysicalCardActivated = 'PHYSICAL_CARD_ACTIVATED',
  ReceiptsScanned = 'RECEIPTS_SCANNED',
  SettingsButtonClicked = 'SETTINGS_BUTTON_CLICKED',
  VirtualCardActivated = 'VIRTUAL_CARD_ACTIVATED'
}

export enum ReviewTriggerPlatform {
  Mobile = 'MOBILE',
  Webapp = 'WEBAPP'
}

export enum RiskClassificationStatus {
  CustomerUnresponsive = 'CUSTOMER_UNRESPONSIVE',
  InformationReceived = 'INFORMATION_RECEIVED',
  InformationRequested = 'INFORMATION_REQUESTED',
  NormalRisk = 'NORMAL_RISK',
  NotScored = 'NOT_SCORED',
  PotentialRisk = 'POTENTIAL_RISK',
  RiskAccepted = 'RISK_ACCEPTED',
  RiskRejected = 'RISK_REJECTED',
  ScoringNotRequired = 'SCORING_NOT_REQUIRED'
}

export enum Skr {
  Skr03 = 'SKR03',
  Skr04 = 'SKR04'
}

export enum ScopeType {
  Accounts = 'ACCOUNTS',
  Admin = 'ADMIN',
  Banners = 'BANNERS',
  CardFraud = 'CARD_FRAUD',
  ChangeRequest = 'CHANGE_REQUEST',
  Clients = 'CLIENTS',
  Offline = 'OFFLINE',
  Overdraft = 'OVERDRAFT',
  Signup = 'SIGNUP',
  Statements = 'STATEMENTS',
  Subscriptions = 'SUBSCRIPTIONS',
  Transactions = 'TRANSACTIONS',
  Transfers = 'TRANSFERS',
  Users = 'USERS'
}

export enum ScreeningProgress {
  NotScreened = 'NOT_SCREENED',
  PotentialMatch = 'POTENTIAL_MATCH',
  ScreenedAccepted = 'SCREENED_ACCEPTED',
  ScreenedDeclined = 'SCREENED_DECLINED'
}

/** Basic Commercial registration provided by Solaris */
export type SearchResult = {
  __typename?: 'SearchResult';
  registrationIssuer?: Maybe<Scalars['String']['output']>;
  registrationNumber: Scalars['String']['output'];
};

export type SeizureProtection = {
  __typename?: 'SeizureProtection';
  currentBlockedAmount: AccountBalance;
  protectedAmount: AccountBalance;
  protectedAmountExpiring: AccountBalance;
  protectedAmountExpiringDate: Scalars['String']['output'];
};

export type SepaTransfer = {
  __typename?: 'SepaTransfer';
  /** The amount of the SEPA Transfer in cents */
  amount: Scalars['Int']['output'];
  /** List of uploaded Asset files for this transfer */
  assets: Array<Asset>;
  /** The end to end ID of the SEPA Transfer */
  e2eId?: Maybe<Scalars['String']['output']>;
  /** The IBAN of the SEPA Transfer recipient */
  iban: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** The purpose of the SEPA Transfer - 140 max characters */
  purpose?: Maybe<Scalars['String']['output']>;
  /** The name of the SEPA Transfer recipient */
  recipient: Scalars['String']['output'];
  /** The status of the SEPA Transfer */
  status: SepaTransferStatus;
};

export enum SepaTransferStatus {
  Authorized = 'AUTHORIZED',
  Booked = 'BOOKED',
  Confirmed = 'CONFIRMED'
}

export type SignupState = {
  __typename?: 'SignupState';
  accounts: Array<Account>;
  beneficialOwners: Array<BeneficialOwner>;
  business?: Maybe<BusinessSignupData>;
  businessIdentification?: Maybe<BusinessIdentification>;
  legalRepresentatives: Array<LegalRepresentativeSignupData>;
  purchases: Array<PurchaseType>;
  user: UserSignupData;
};

export type SolarisAccountBalance = {
  __typename?: 'SolarisAccountBalance';
  availableBalance?: Maybe<AccountBalance>;
  balance?: Maybe<AccountBalance>;
  seizureProtection?: Maybe<SeizureProtection>;
};

export type SolarisBusinessAddress = {
  __typename?: 'SolarisBusinessAddress';
  city: Scalars['String']['output'];
  country: Scalars['String']['output'];
  line1: Scalars['String']['output'];
  line2?: Maybe<Scalars['String']['output']>;
  postalCode: Scalars['String']['output'];
  state?: Maybe<Scalars['String']['output']>;
};

export enum StandingOrderReoccurrenceType {
  Annually = 'ANNUALLY',
  Biweekly = 'BIWEEKLY',
  EverySixMonths = 'EVERY_SIX_MONTHS',
  Monthly = 'MONTHLY',
  Quarterly = 'QUARTERLY',
  Weekly = 'WEEKLY'
}

export enum Status {
  Error = 'ERROR'
}

export type SubAccount = {
  __typename?: 'SubAccount';
  balance?: Maybe<Scalars['Float']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  iban?: Maybe<Scalars['String']['output']>;
  icon: Scalars['String']['output'];
  name: Scalars['String']['output'];
  publicId?: Maybe<Scalars['String']['output']>;
  status: AccountOpeningRequestStatus;
};

export type SubAccountOpeningRequest = {
  icon: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type SubAccountUpdateRequest = {
  icon?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  publicId: Scalars['String']['input'];
};

export enum SubmissionStatus {
  AlreadySubmitted = 'ALREADY_SUBMITTED',
  NotNeeded = 'NOT_NEEDED'
}

export type SubmitComplianceQuestionInput = {
  answer: Scalars['String']['input'];
  questionId: Scalars['String']['input'];
};

export type SubmitQuestionSetInput = {
  answers: Array<QuestionAnswer>;
  questionSetId: Scalars['String']['input'];
};

export type Subscription = {
  __typename?: 'Subscription';
  newTransaction: Transaction;
};

export type SubscriptionFeature = {
  __typename?: 'SubscriptionFeature';
  icon?: Maybe<Icon>;
  title: Scalars['String']['output'];
};

export type SubscriptionFeatureGroup = {
  __typename?: 'SubscriptionFeatureGroup';
  features: Array<SubscriptionFeature>;
  icon?: Maybe<Icon>;
  title?: Maybe<Scalars['String']['output']>;
};

export type SubscriptionPlan = {
  __typename?: 'SubscriptionPlan';
  /** @deprecated For backwards compatibility on mobile only. From now on use the button copy coming from Lokalise instead. */
  button?: Maybe<Scalars['String']['output']>;
  /** @deprecated For backwards compatibility on mobile only. From now on use the description copy coming from Lokalise instead. */
  description?: Maybe<Scalars['String']['output']>;
  /** @deprecated For backwards compatibility on mobile only. From now on use the features copy coming from Lokalise instead. */
  featureGroups?: Maybe<Array<SubscriptionFeatureGroup>>;
  /** @deprecated For backwards compatibility on mobile only. */
  featuresToggleLabel?: Maybe<Scalars['String']['output']>;
  fee: Money;
  subtitle?: Maybe<Scalars['String']['output']>;
  /** @deprecated For backwards compatibility on mobile only. From now on use the title copy coming from Lokalise instead. */
  title?: Maybe<Scalars['String']['output']>;
  type: PurchaseType;
};

export type SubscriptionPlansResponse = {
  __typename?: 'SubscriptionPlansResponse';
  couponCode?: Maybe<Scalars['String']['output']>;
  couponValidFor?: Maybe<Array<PurchaseType>>;
  plans: Array<SubscriptionPlan>;
};

export type SystemStatus = {
  __typename?: 'SystemStatus';
  message?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Status>;
};

export type TaxCase = {
  __typename?: 'TaxCase';
  businessTaxFinalizedAt?: Maybe<Scalars['DateTime']['output']>;
  deadline: Scalars['DateTime']['output'];
  finalizedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  incomeTaxFinalizedAt?: Maybe<Scalars['DateTime']['output']>;
  incomeTaxSkippedAt?: Maybe<Scalars['DateTime']['output']>;
  status: TaxCaseStatus;
  taxOfficeDeadline?: Maybe<Scalars['DateTime']['output']>;
  userFinalizedAt?: Maybe<Scalars['DateTime']['output']>;
  year: Scalars['Int']['output'];
};

export enum TaxCaseStatus {
  Done = 'DONE',
  InProgress = 'IN_PROGRESS',
  NotStarted = 'NOT_STARTED'
}

export enum TaxConfirmation {
  Annualy = 'ANNUALY',
  Single = 'SINGLE'
}

export type TaxDeclaration = {
  __typename?: 'TaxDeclaration';
  declarationApproval?: Maybe<DeclarationApproval>;
  declarationType: TaxDeclarationType;
  finalForms?: Maybe<TaxDeclarationSubmissionInfo>;
  id: Scalars['ID']['output'];
  previewForms?: Maybe<TaxDeclarationSavedDraftInfo>;
  status: TaxDeclarationStatus;
  statusUpdatedAt?: Maybe<Scalars['DateTime']['output']>;
  year: Scalars['Int']['output'];
};

export type TaxDeclarationExternalAsset = {
  __typename?: 'TaxDeclarationExternalAsset';
  createdAt: Scalars['DateTime']['output'];
  filetype: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type TaxDeclarationSavedDraftInfo = {
  __typename?: 'TaxDeclarationSavedDraftInfo';
  calculationSheetUrl?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  createdBy?: Maybe<Scalars['String']['output']>;
  externalAssets?: Maybe<Array<TaxDeclarationExternalAsset>>;
  pdfUrl?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export enum TaxDeclarationStatus {
  AppealProcessCompleted = 'APPEAL_PROCESS_COMPLETED',
  AppealProcessStarted = 'APPEAL_PROCESS_STARTED',
  ApprovedByTaxConsultant = 'APPROVED_BY_TAX_CONSULTANT',
  ApprovedByUser = 'APPROVED_BY_USER',
  Closed = 'CLOSED',
  CompletedByData = 'COMPLETED_BY_DATA',
  CompletedByOps = 'COMPLETED_BY_OPS',
  ConsultationData = 'CONSULTATION_DATA',
  InProgressData = 'IN_PROGRESS_DATA',
  InProgressOps = 'IN_PROGRESS_OPS',
  InProgressTaxConsultant = 'IN_PROGRESS_TAX_CONSULTANT',
  NotRelevant = 'NOT_RELEVANT',
  ObjectedByFinanzamt = 'OBJECTED_BY_FINANZAMT',
  ObjectedByTaxConsultant = 'OBJECTED_BY_TAX_CONSULTANT',
  ObjectedByUser = 'OBJECTED_BY_USER',
  Open = 'OPEN',
  ReceivedTaxBill = 'RECEIVED_TAX_BILL',
  Submitted = 'SUBMITTED',
  WaitingForUserApproval = 'WAITING_FOR_USER_APPROVAL'
}

export type TaxDeclarationSubmissionInfo = {
  __typename?: 'TaxDeclarationSubmissionInfo';
  calculationSheetUrl?: Maybe<Scalars['String']['output']>;
  externalAssets?: Maybe<Array<TaxDeclarationExternalAsset>>;
  pdfUrl?: Maybe<Scalars['String']['output']>;
  submissionAgent?: Maybe<Scalars['String']['output']>;
  submissionDate?: Maybe<Scalars['DateTime']['output']>;
};

export enum TaxDeclarationType {
  Euer = 'EUER',
  IncomeTax = 'INCOME_TAX',
  TradeTax = 'TRADE_TAX',
  VatAnnual = 'VAT_ANNUAL'
}

/** Tax numbers of users */
export type TaxNumber = {
  __typename?: 'TaxNumber';
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isMainBusinessTaxNumber: Scalars['Boolean']['output'];
  taxNumber: Scalars['String']['output'];
  type: TaxNumberType;
  validFrom?: Maybe<Scalars['DateTime']['output']>;
};

export enum TaxNumberType {
  Business = 'BUSINESS',
  Personal = 'PERSONAL'
}

export enum TaxPaymentFrequency {
  Quarterly = 'QUARTERLY'
}

export type TaxYearSetting = {
  __typename?: 'TaxYearSetting';
  /** Flag if the corresponding year should be excluded from the tax calculations completely */
  excluded?: Maybe<Scalars['Boolean']['output']>;
  /** Tax rate that should be applied in the corresponding year */
  taxRate?: Maybe<Scalars['Int']['output']>;
  /** Tax year the individual settings apply to */
  year: Scalars['Int']['output'];
};

export type TaxYearSettingInput = {
  /** Flag if the corresponding year should be excluded from the tax calculations completely */
  excluded?: InputMaybe<Scalars['Boolean']['input']>;
  /** Tax rate that should be applied in the corresponding year */
  taxRate?: InputMaybe<Scalars['Int']['input']>;
  /** Tax year the individual settings apply to */
  year: Scalars['Int']['input'];
};

/** Terms And conditions */
export type TermsAndConditions = {
  __typename?: 'TermsAndConditions';
  businessId?: Maybe<Scalars['String']['output']>;
  confirmedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  name: TermsAndConditionsName;
  rejectedAt?: Maybe<Scalars['DateTime']['output']>;
};

export enum TermsAndConditionsName {
  InstantCreditTransfer = 'INSTANT_CREDIT_TRANSFER',
  Loan = 'LOAN',
  Subaccount = 'SUBACCOUNT',
  TopUp = 'TOP_UP'
}

export enum ThreeStateAnswer {
  No = 'NO',
  NotSure = 'NOT_SURE',
  Yes = 'YES'
}

export type TopUpCreationResult = {
  __typename?: 'TopUpCreationResult';
  clientSecret: Scalars['String']['output'];
};

export type TopUpInput = {
  amount: Scalars['Float']['input'];
  paymentMethodId?: InputMaybe<Scalars['String']['input']>;
};

export enum TourName {
  BizTaxQuestionnairePreview = 'BIZ_TAX_QUESTIONNAIRE_PREVIEW',
  BizTaxTrial = 'BIZ_TAX_TRIAL',
  BookkeepingOnboarding = 'BOOKKEEPING_ONBOARDING'
}

export enum TourStatus {
  Dismissed = 'DISMISSED',
  Finished = 'FINISHED',
  Started = 'STARTED'
}

export type Transaction = {
  __typename?: 'Transaction';
  actionReason?: Maybe<ActionReason>;
  /** The amount of the transaction in cents */
  amount: Scalars['Int']['output'];
  /** View a single Asset for a transaction */
  asset?: Maybe<TransactionAsset>;
  /** List of uploaded Asset files for this transaction */
  assets: Array<TransactionAsset>;
  /** The date at which the transaction was booked (created) */
  bookingDate: Scalars['DateTime']['output'];
  /** View a single Business Asset for a transaction */
  businessAsset?: Maybe<BusinessAssetResponse>;
  canBeRecategorized: Scalars['Boolean']['output'];
  categorizationType?: Maybe<CategorizationType>;
  category?: Maybe<TransactionCategory>;
  categoryCode?: Maybe<Scalars['String']['output']>;
  categoryCodeTranslation?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  directDebitFees: Array<DirectDebitFee>;
  documentDownloadUrl?: Maybe<Scalars['String']['output']>;
  documentNumber?: Maybe<Scalars['String']['output']>;
  documentPreviewUrl?: Maybe<Scalars['String']['output']>;
  documentType?: Maybe<DocumentType>;
  e2eId?: Maybe<Scalars['String']['output']>;
  fees: Array<TransactionFee>;
  foreignCurrency?: Maybe<Scalars['String']['output']>;
  hasAssets: Scalars['Boolean']['output'];
  iban?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  mandateNumber?: Maybe<Scalars['String']['output']>;
  merchantCategoryCode?: Maybe<Scalars['String']['output']>;
  merchantCountryCode?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  originalAmount?: Maybe<Scalars['Float']['output']>;
  paymentMethod: Scalars['String']['output'];
  personalNote?: Maybe<Scalars['String']['output']>;
  predictedCategory?: Maybe<TransactionCategory>;
  /** Date predicted for tax/vat payment/refund predicted category */
  predictedUserSelectedBookingDate?: Maybe<Scalars['DateTime']['output']>;
  purpose?: Maybe<Scalars['String']['output']>;
  receiptName?: Maybe<Scalars['String']['output']>;
  recurlyInvoiceNumber?: Maybe<Scalars['String']['output']>;
  source: TransactionSource;
  /** Metadata of separate pseudo-transactions created when splitting the parent transaction */
  splits: Array<TransactionSplit>;
  /** View a single Asset for a transaction */
  transactionAsset?: Maybe<Asset>;
  /** List Assets for a transaction */
  transactionAssets: Array<Asset>;
  type: TransactionProjectionType;
  /** When a transaction corresponds to a tax or vat payment, the user may specify at which date it should be considered booked */
  userSelectedBookingDate?: Maybe<Scalars['DateTime']['output']>;
  /** The date at which the transaction was processed and the amount deducted from the user's account */
  valutaDate?: Maybe<Scalars['DateTime']['output']>;
  vatCategoryCode?: Maybe<Scalars['String']['output']>;
  vatRate?: Maybe<VatRate>;
  verified?: Maybe<Scalars['Boolean']['output']>;
};


export type TransactionAssetArgs = {
  assetId: Scalars['ID']['input'];
};


export type TransactionTransactionAssetArgs = {
  assetId: Scalars['ID']['input'];
};

export type TransactionAsset = {
  __typename?: 'TransactionAsset';
  assetableId: Scalars['ID']['output'];
  filetype: Scalars['String']['output'];
  fullsize: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  path: Scalars['String']['output'];
  thumbnail: Scalars['String']['output'];
};

export enum TransactionCategory {
  Private = 'PRIVATE',
  ReverseCharge = 'REVERSE_CHARGE',
  TaxPayment = 'TAX_PAYMENT',
  TaxRefund = 'TAX_REFUND',
  TaxSaving = 'TAX_SAVING',
  Vat = 'VAT',
  Vat_0 = 'VAT_0',
  Vat_5 = 'VAT_5',
  Vat_7 = 'VAT_7',
  Vat_16 = 'VAT_16',
  Vat_19 = 'VAT_19',
  VatPayment = 'VAT_PAYMENT',
  VatRefund = 'VAT_REFUND',
  VatSaving = 'VAT_SAVING'
}

export type TransactionCondition = {
  amount_eq?: InputMaybe<Scalars['Int']['input']>;
  amount_gt?: InputMaybe<Scalars['Int']['input']>;
  amount_gte?: InputMaybe<Scalars['Int']['input']>;
  amount_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  amount_lt?: InputMaybe<Scalars['Int']['input']>;
  amount_lte?: InputMaybe<Scalars['Int']['input']>;
  amount_ne?: InputMaybe<Scalars['Int']['input']>;
  assets_exist?: InputMaybe<Scalars['Boolean']['input']>;
  bookingDate_eq?: InputMaybe<Scalars['DateTime']['input']>;
  bookingDate_gt?: InputMaybe<Scalars['DateTime']['input']>;
  bookingDate_gte?: InputMaybe<Scalars['DateTime']['input']>;
  bookingDate_lt?: InputMaybe<Scalars['DateTime']['input']>;
  bookingDate_lte?: InputMaybe<Scalars['DateTime']['input']>;
  bookingDate_ne?: InputMaybe<Scalars['DateTime']['input']>;
  categoryCode_exist?: InputMaybe<Scalars['Boolean']['input']>;
  category_eq?: InputMaybe<TransactionCategory>;
  category_in?: InputMaybe<Array<TransactionCategory>>;
  iban_eq?: InputMaybe<Scalars['String']['input']>;
  iban_in?: InputMaybe<Array<Scalars['String']['input']>>;
  iban_like?: InputMaybe<Scalars['String']['input']>;
  iban_likeAny?: InputMaybe<Array<Scalars['String']['input']>>;
  iban_ne?: InputMaybe<Scalars['String']['input']>;
  name_eq?: InputMaybe<Scalars['String']['input']>;
  name_in?: InputMaybe<Array<Scalars['String']['input']>>;
  name_like?: InputMaybe<Scalars['String']['input']>;
  name_likeAny?: InputMaybe<Array<Scalars['String']['input']>>;
  name_ne?: InputMaybe<Scalars['String']['input']>;
  operator?: InputMaybe<BaseOperator>;
  purpose_eq?: InputMaybe<Scalars['String']['input']>;
  purpose_like?: InputMaybe<Scalars['String']['input']>;
  purpose_likeAny?: InputMaybe<Array<Scalars['String']['input']>>;
  purpose_ne?: InputMaybe<Scalars['String']['input']>;
  source_eq?: InputMaybe<Scalars['String']['input']>;
  source_in?: InputMaybe<Array<Scalars['String']['input']>>;
  source_ne?: InputMaybe<Scalars['String']['input']>;
  splits_exist?: InputMaybe<Scalars['Boolean']['input']>;
  type_eq?: InputMaybe<TransactionProjectionType>;
  valutaDate_eq?: InputMaybe<Scalars['DateTime']['input']>;
  valutaDate_gt?: InputMaybe<Scalars['DateTime']['input']>;
  valutaDate_gte?: InputMaybe<Scalars['DateTime']['input']>;
  valutaDate_lt?: InputMaybe<Scalars['DateTime']['input']>;
  valutaDate_lte?: InputMaybe<Scalars['DateTime']['input']>;
  valutaDate_ne?: InputMaybe<Scalars['DateTime']['input']>;
  vatAssets_exist?: InputMaybe<Scalars['Boolean']['input']>;
  vatCategoryCode_exist?: InputMaybe<Scalars['Boolean']['input']>;
};

export type TransactionFee = {
  __typename?: 'TransactionFee';
  status: TransactionFeeStatus;
  type: TransactionFeeType;
  unitAmount?: Maybe<Scalars['Int']['output']>;
  usedAt?: Maybe<Scalars['DateTime']['output']>;
};

export enum TransactionFeeStatus {
  Cancelled = 'CANCELLED',
  Charged = 'CHARGED',
  Created = 'CREATED',
  Refunded = 'REFUNDED',
  RefundInitiated = 'REFUND_INITIATED'
}

export enum TransactionFeeType {
  Atm = 'ATM',
  AtmFx = 'ATM_FX',
  CardFx = 'CARD_FX',
  CardReplacement = 'CARD_REPLACEMENT',
  DirectDebitReturn = 'DIRECT_DEBIT_RETURN',
  ForeignTransaction = 'FOREIGN_TRANSACTION',
  FreeKontistTransaction = 'FREE_KONTIST_TRANSACTION',
  InstantCreditTransfer = 'INSTANT_CREDIT_TRANSFER',
  KontistTransaction = 'KONTIST_TRANSACTION',
  SecondReminderEmail = 'SECOND_REMINDER_EMAIL',
  Sepa = 'SEPA',
  TopUp = 'TOP_UP'
}

export type TransactionFilter = {
  amount_eq?: InputMaybe<Scalars['Int']['input']>;
  amount_gt?: InputMaybe<Scalars['Int']['input']>;
  amount_gte?: InputMaybe<Scalars['Int']['input']>;
  amount_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  amount_lt?: InputMaybe<Scalars['Int']['input']>;
  amount_lte?: InputMaybe<Scalars['Int']['input']>;
  amount_ne?: InputMaybe<Scalars['Int']['input']>;
  assets_exist?: InputMaybe<Scalars['Boolean']['input']>;
  bookingDate_eq?: InputMaybe<Scalars['DateTime']['input']>;
  bookingDate_gt?: InputMaybe<Scalars['DateTime']['input']>;
  bookingDate_gte?: InputMaybe<Scalars['DateTime']['input']>;
  bookingDate_lt?: InputMaybe<Scalars['DateTime']['input']>;
  bookingDate_lte?: InputMaybe<Scalars['DateTime']['input']>;
  bookingDate_ne?: InputMaybe<Scalars['DateTime']['input']>;
  categoryCode_exist?: InputMaybe<Scalars['Boolean']['input']>;
  category_eq?: InputMaybe<TransactionCategory>;
  category_in?: InputMaybe<Array<TransactionCategory>>;
  conditions?: InputMaybe<Array<TransactionCondition>>;
  iban_eq?: InputMaybe<Scalars['String']['input']>;
  iban_in?: InputMaybe<Array<Scalars['String']['input']>>;
  iban_like?: InputMaybe<Scalars['String']['input']>;
  iban_likeAny?: InputMaybe<Array<Scalars['String']['input']>>;
  iban_ne?: InputMaybe<Scalars['String']['input']>;
  name_eq?: InputMaybe<Scalars['String']['input']>;
  name_in?: InputMaybe<Array<Scalars['String']['input']>>;
  name_like?: InputMaybe<Scalars['String']['input']>;
  name_likeAny?: InputMaybe<Array<Scalars['String']['input']>>;
  name_ne?: InputMaybe<Scalars['String']['input']>;
  operator?: InputMaybe<BaseOperator>;
  purpose_eq?: InputMaybe<Scalars['String']['input']>;
  purpose_like?: InputMaybe<Scalars['String']['input']>;
  purpose_likeAny?: InputMaybe<Array<Scalars['String']['input']>>;
  purpose_ne?: InputMaybe<Scalars['String']['input']>;
  source_eq?: InputMaybe<Scalars['String']['input']>;
  source_in?: InputMaybe<Array<Scalars['String']['input']>>;
  source_ne?: InputMaybe<Scalars['String']['input']>;
  splits_exist?: InputMaybe<Scalars['Boolean']['input']>;
  type_eq?: InputMaybe<TransactionProjectionType>;
  valutaDate_eq?: InputMaybe<Scalars['DateTime']['input']>;
  valutaDate_gt?: InputMaybe<Scalars['DateTime']['input']>;
  valutaDate_gte?: InputMaybe<Scalars['DateTime']['input']>;
  valutaDate_lt?: InputMaybe<Scalars['DateTime']['input']>;
  valutaDate_lte?: InputMaybe<Scalars['DateTime']['input']>;
  valutaDate_ne?: InputMaybe<Scalars['DateTime']['input']>;
  vatAssets_exist?: InputMaybe<Scalars['Boolean']['input']>;
  vatCategoryCode_exist?: InputMaybe<Scalars['Boolean']['input']>;
};

export type TransactionForAccountingView = {
  __typename?: 'TransactionForAccountingView';
  amount: Scalars['Int']['output'];
  category?: Maybe<TransactionCategory>;
  categoryCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  isSplit: Scalars['Boolean']['output'];
  name?: Maybe<Scalars['String']['output']>;
  purpose?: Maybe<Scalars['String']['output']>;
  selectedBookingDate?: Maybe<Scalars['DateTime']['output']>;
  valutaDate: Scalars['DateTime']['output'];
  vatAmount?: Maybe<Scalars['Int']['output']>;
  vatCategoryCode?: Maybe<Scalars['String']['output']>;
  vatRate?: Maybe<Scalars['String']['output']>;
};

export enum TransactionProjectionType {
  Atm = 'ATM',
  CancellationBooking = 'CANCELLATION_BOOKING',
  CancellationCardTransaction = 'CANCELLATION_CARD_TRANSACTION',
  CancellationCharge = 'CANCELLATION_CHARGE',
  CancellationDirectDebit = 'CANCELLATION_DIRECT_DEBIT',
  CancellationDoubleBooking = 'CANCELLATION_DOUBLE_BOOKING',
  CancellationInterestAccrued = 'CANCELLATION_INTEREST_ACCRUED',
  CancellationSepaCreditTransferReturn = 'CANCELLATION_SEPA_CREDIT_TRANSFER_RETURN',
  CancellationSepaDirectDebitReturn = 'CANCELLATION_SEPA_DIRECT_DEBIT_RETURN',
  CancelManualLoad = 'CANCEL_MANUAL_LOAD',
  CardTransaction = 'CARD_TRANSACTION',
  CardUsage = 'CARD_USAGE',
  CashAtmReversal = 'CASH_ATM_REVERSAL',
  CashManual = 'CASH_MANUAL',
  CashManualReversal = 'CASH_MANUAL_REVERSAL',
  Charge = 'CHARGE',
  CommissionOverdraft = 'COMMISSION_OVERDRAFT',
  CreditPresentment = 'CREDIT_PRESENTMENT',
  CreditTransferCancellation = 'CREDIT_TRANSFER_CANCELLATION',
  CurrencyTransactionCancellation = 'CURRENCY_TRANSACTION_CANCELLATION',
  ChargeRecallRequest = 'ChargeRecallRequest',
  CorrectionCardTransaction = 'CorrectionCardTransaction',
  CorrectionNostro = 'CorrectionNostro',
  CorrectionSepaCreditTransfer = 'CorrectionSEPACreditTransfer',
  DebitPresentment = 'DEBIT_PRESENTMENT',
  DepositFee = 'DEPOSIT_FEE',
  DirectDebit = 'DIRECT_DEBIT',
  DirectDebitAutomaticTopup = 'DIRECT_DEBIT_AUTOMATIC_TOPUP',
  DirectDebitReturn = 'DIRECT_DEBIT_RETURN',
  DisputeClearing = 'DISPUTE_CLEARING',
  DisputeTransaction = 'DISPUTE_TRANSACTION',
  ExternalTransaction = 'EXTERNAL_TRANSACTION',
  ExternalTransactionCash = 'EXTERNAL_TRANSACTION_CASH',
  FailedCardUsage = 'FAILED_CARD_USAGE',
  ForcePostTransaction = 'FORCE_POST_TRANSACTION',
  ForeignPayment = 'FOREIGN_PAYMENT',
  InterestAccrued = 'INTEREST_ACCRUED',
  InternalTransfer = 'INTERNAL_TRANSFER',
  InternationalCreditTransfer = 'INTERNATIONAL_CREDIT_TRANSFER',
  IntraCustomerTransfer = 'INTRA_CUSTOMER_TRANSFER',
  InterestExcessDeposit = 'InterestExcessDeposit',
  InterestOverdraft = 'InterestOverdraft',
  InterestOverdraftExceeded = 'InterestOverdraftExceeded',
  ManualLoad = 'MANUAL_LOAD',
  Oct = 'OCT',
  Other = 'OTHER',
  PurchaseReversal = 'PURCHASE_REVERSAL',
  Rebooking = 'REBOOKING',
  RebookedSepaCreditTransferReturn = 'RebookedSEPACreditTransferReturn',
  RebookedSepaDirectDebitCoreReturn = 'RebookedSEPADirectDebitCoreReturn',
  ReimbursementCustomer = 'ReimbursementCustomer',
  SepaInstantCreditTransfer = 'SEPAInstantCreditTransfer',
  SepaCreditTransfer = 'SEPA_CREDIT_TRANSFER',
  SepaCreditTransferReturn = 'SEPA_CREDIT_TRANSFER_RETURN',
  SepaDirectDebit = 'SEPA_DIRECT_DEBIT',
  SepaDirectDebitReturn = 'SEPA_DIRECT_DEBIT_RETURN',
  Transfer = 'TRANSFER',
  TransferToBankAccount = 'TRANSFER_TO_BANK_ACCOUNT',
  Target2CreditTransfer1 = 'Target2CreditTransfer1',
  Target2CreditTransfer2 = 'Target2CreditTransfer2',
  TopUpCard = 'TopUpCard',
  TopUpCardChargeback = 'TopUpCardChargeback',
  TopUpCardRefund = 'TopUpCardRefund',
  VerificationCode = 'VERIFICATION_CODE',
  WireTransferTopup = 'WIRE_TRANSFER_TOPUP'
}

export enum TransactionSource {
  BackofficeManual = 'BACKOFFICE_MANUAL',
  Solaris = 'SOLARIS',
  User = 'USER'
}

export type TransactionSplit = {
  __typename?: 'TransactionSplit';
  amount: Scalars['Int']['output'];
  categorizationType?: Maybe<CategorizationType>;
  category?: Maybe<TransactionCategory>;
  categoryCode?: Maybe<Scalars['String']['output']>;
  categoryCodeTranslation?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  userSelectedBookingDate?: Maybe<Scalars['DateTime']['output']>;
  uuid: Scalars['ID']['output'];
  vatCategoryCode?: Maybe<VatCategoryCode>;
  vatRate?: Maybe<VatRate>;
};

export type TransactionSplitInput = {
  amount: Scalars['Int']['input'];
  category?: InputMaybe<TransactionCategory>;
  categoryCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userSelectedBookingDate?: InputMaybe<Scalars['DateTime']['input']>;
  vatCategoryCode?: InputMaybe<Scalars['String']['input']>;
  vatRate?: InputMaybe<VatRate>;
};

export type TransactionsConnection = {
  __typename?: 'TransactionsConnection';
  edges: Array<TransactionsConnectionEdge>;
  pageInfo: PageInfo;
};

export type TransactionsConnectionEdge = {
  __typename?: 'TransactionsConnectionEdge';
  cursor: Scalars['String']['output'];
  node: Transaction;
};

export type Transfer = {
  __typename?: 'Transfer';
  /** The amount of the transfer in cents */
  amount: Scalars['Int']['output'];
  /** List of uploaded Asset files for this transfer */
  assets?: Maybe<Array<Asset>>;
  /** The user selected category for the SEPA Transfer */
  category?: Maybe<TransactionCategory>;
  /** The end to end ID of the transfer */
  e2eId?: Maybe<Scalars['String']['output']>;
  /** The date at which the payment will be executed for Timed Orders or Standing Orders */
  executeAt?: Maybe<Scalars['DateTime']['output']>;
  /** The IBAN of the transfer recipient */
  iban: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** The date at which the last payment will be executed for Standing Orders */
  lastExecutionDate?: Maybe<Scalars['DateTime']['output']>;
  /** The date at which the next payment will be executed for Standing Orders */
  nextOccurrence?: Maybe<Scalars['DateTime']['output']>;
  /** The personal note of the transfer - 250 max characters */
  personalNote?: Maybe<Scalars['String']['output']>;
  /** The purpose of the transfer - 140 max characters */
  purpose?: Maybe<Scalars['String']['output']>;
  /** The name of the transfer recipient */
  recipient: Scalars['String']['output'];
  /** Unique id of transfer session */
  reference?: Maybe<Scalars['String']['output']>;
  /** The reoccurrence type of the payments for Standing Orders */
  reoccurrence?: Maybe<StandingOrderReoccurrenceType>;
  /** The status of the transfer */
  status?: Maybe<TransferStatus>;
  /** When a transaction corresponds to a tax or vat payment, the user may specify at which date it should be considered booked */
  userSelectedBookingDate?: Maybe<Scalars['DateTime']['output']>;
  uuid: Scalars['String']['output'];
};

export enum TransferStatus {
  Active = 'ACTIVE',
  AuthorizationRequired = 'AUTHORIZATION_REQUIRED',
  Authorized = 'AUTHORIZED',
  Booked = 'BOOKED',
  Canceled = 'CANCELED',
  ConfirmationRequired = 'CONFIRMATION_REQUIRED',
  Confirmed = 'CONFIRMED',
  Created = 'CREATED',
  Executed = 'EXECUTED',
  Failed = 'FAILED',
  Inactive = 'INACTIVE',
  Scheduled = 'SCHEDULED'
}

export type TransferSuggestion = {
  __typename?: 'TransferSuggestion';
  iban: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export enum TransferType {
  InstantCreditTransfer = 'INSTANT_CREDIT_TRANSFER',
  SepaTransfer = 'SEPA_TRANSFER',
  StandingOrder = 'STANDING_ORDER',
  TimedOrder = 'TIMED_ORDER'
}

export type TransfersConnection = {
  __typename?: 'TransfersConnection';
  edges: Array<TransfersConnectionEdge>;
  pageInfo: PageInfo;
};

export type TransfersConnectionEdge = {
  __typename?: 'TransfersConnectionEdge';
  cursor: Scalars['String']['output'];
  node: Transfer;
};

export type TransfersConnectionFilter = {
  status?: InputMaybe<TransferStatus>;
};

export type UnfinishedTransfer = {
  __typename?: 'UnfinishedTransfer';
  amount: Scalars['Int']['output'];
  iban: Scalars['String']['output'];
  purpose: Scalars['String']['output'];
  recipient: Scalars['String']['output'];
};

export type UpdateBeneficialOwnerInput = {
  birthDate?: InputMaybe<Scalars['DateTime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Nationality>;
  fatcaCrsConfirmedAt?: InputMaybe<Scalars['DateTime']['input']>;
  fatcaRelevant?: InputMaybe<Scalars['Boolean']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Gender>;
  id: Scalars['String']['input'];
  lastName?: InputMaybe<Scalars['String']['input']>;
  legalRepresentativeId?: InputMaybe<Scalars['String']['input']>;
  nationality?: InputMaybe<Nationality>;
  postCode?: InputMaybe<Scalars['String']['input']>;
  street?: InputMaybe<Scalars['String']['input']>;
  taxCountry?: InputMaybe<Nationality>;
  taxId?: InputMaybe<Scalars['String']['input']>;
  votingShare?: InputMaybe<Scalars['String']['input']>;
};

/** The available fields to update an OAuth2 client */
export type UpdateClientInput = {
  /** The grant types (i.e. ways to obtain access tokens) allowed for the client */
  grantTypes?: InputMaybe<Array<GrantType>>;
  /** The id of the OAuth2 client to update */
  id: Scalars['String']['input'];
  /** The name of the OAuth2 client displayed when users log in */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The URL to redirect to after authentication */
  redirectUri?: InputMaybe<Scalars['String']['input']>;
  /** The scopes the client has access to, limiting access to the corresponding parts of the API */
  scopes?: InputMaybe<Array<ScopeType>>;
  /** The OAuth2 client secret */
  secret?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateContactArgs = {
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  iban?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateDocumentMetadata = {
  /** Document's category Id */
  documentCategoryId?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateDraftTransactionInput = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  assetUploaded?: InputMaybe<Scalars['Boolean']['input']>;
  businessAsset?: InputMaybe<BusinessAssetInput>;
  categoryCode?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  isCashTransaction?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  paymentDate?: InputMaybe<Scalars['DateTime']['input']>;
  splits?: InputMaybe<Array<TransactionSplitInput>>;
  vatCategoryCode?: InputMaybe<Scalars['String']['input']>;
  vatRate?: InputMaybe<VatRate>;
};

export type UpdateSolarisUserInput = {
  address?: InputMaybe<AddressInput>;
  amlConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  businessAddress?: InputMaybe<BusinessAddressInput>;
  businessPurpose?: InputMaybe<Scalars['String']['input']>;
  businessTradingName?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  expectedMonthlyRevenueCents?: InputMaybe<Scalars['Int']['input']>;
  naceCode?: InputMaybe<Scalars['String']['input']>;
  naceCodeId?: InputMaybe<Scalars['Float']['input']>;
  websiteSocialMedia?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateSubscriptionPlanResult = {
  __typename?: 'UpdateSubscriptionPlanResult';
  couponCode?: Maybe<Scalars['String']['output']>;
  hasCanceledDowngrade: Scalars['Boolean']['output'];
  hasOrderedPhysicalCard: Scalars['Boolean']['output'];
  newPlan: Scalars['String']['output'];
  previousPlans: Array<PurchaseType>;
  updateActiveAt: Scalars['String']['output'];
};

export type UpdateTaxNumberInput = {
  description: Scalars['String']['input'];
  isMainBusinessTaxNumber: Scalars['Boolean']['input'];
  taxNumber: Scalars['String']['input'];
  type: TaxNumberType;
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UpdateTermsAndConditionsArgs = {
  businessId?: InputMaybe<Scalars['String']['input']>;
  confirmed: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
};

export type UpdateTransactionSplitsInput = {
  amount: Scalars['Int']['input'];
  category?: InputMaybe<TransactionCategory>;
  categoryCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userSelectedBookingDate?: InputMaybe<Scalars['DateTime']['input']>;
  vatCategoryCode?: InputMaybe<Scalars['String']['input']>;
  vatRate?: InputMaybe<VatRate>;
};

/** The available fields to update a transfer */
export type UpdateTransferInput = {
  /** The amount of the Standing Order payment in cents */
  amount?: InputMaybe<Scalars['Int']['input']>;
  /** The user selected category for the SEPA Transfer */
  category?: InputMaybe<TransactionCategory>;
  /** The end to end ID of the Standing Order, if not specified with the update, it will be set to null */
  e2eId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the transfer to update */
  id: Scalars['String']['input'];
  /** The date at which the last payment will be executed */
  lastExecutionDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** The personal note of the transfer - 250 max characters */
  personalNote?: InputMaybe<Scalars['String']['input']>;
  /** The purpose of the Standing Order - 140 max characters, if not specified with the update, it will be set to null */
  purpose?: InputMaybe<Scalars['String']['input']>;
  /** Unique id of transfer session */
  reference?: InputMaybe<Scalars['String']['input']>;
  /** The reoccurrence type of the payments for Standing Orders */
  reoccurrence?: InputMaybe<StandingOrderReoccurrenceType>;
  /** The type of transfer to update, currently only Standing Orders are supported */
  type: TransferType;
  /** When a transaction corresponds to a tax or vat payment, the user may specify at which date it should be considered booked */
  userSelectedBookingDate?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UpsertAddressInput = {
  city: Scalars['String']['input'];
  country: Scalars['String']['input'];
  postCode: Scalars['String']['input'];
  street: Scalars['String']['input'];
};

export type UpsertDeclarationArgs = {
  period: Scalars['String']['input'];
  submissionStatus: SubmissionStatus;
  year: Scalars['Int']['input'];
};

export type UpsertUserTourInput = {
  name: TourName;
  status: TourStatus;
};

export type User = {
  __typename?: 'User';
  /** The current state of user's Kontist account based on his subscription plan */
  accountState?: Maybe<AccountState>;
  amlConfirmedOn?: Maybe<Scalars['DateTime']['output']>;
  amlFollowUpDate?: Maybe<Scalars['DateTime']['output']>;
  /** Information about the plans a user can subscribe to */
  availablePlans: Array<SubscriptionPlan>;
  /** The state of banners in mobile or web app for the user */
  banners?: Maybe<Array<Banner>>;
  birthDate?: Maybe<Scalars['DateTime']['output']>;
  birthPlace?: Maybe<Scalars['String']['output']>;
  bizTaxBookkeepingConfirmation?: Maybe<BizTaxBookkeepingConfirmation>;
  bizTaxDeclarationChecks: Array<BizTaxDeclarationCheckResult>;
  bizTaxDeclarationSetting: BizTaxDeclarationSetting;
  bizTaxDeclarationSubmissions: Array<BizTaxDeclarationSubmission>;
  bizTaxQuestionnairesEuer: BizTaxQuestionnairesEuer;
  biztaxTrialBannerDismissedAt?: Maybe<Scalars['DateTime']['output']>;
  businessAddress?: Maybe<UserBusinessAddress>;
  /** User's business addresses */
  businessAddresses: Array<BusinessAddress>;
  /** Return a business asset by id */
  businessAsset?: Maybe<BusinessAssetResponse>;
  /** User's business assets */
  businessAssets?: Maybe<Array<BusinessAssetResponse>>;
  /** Business description provided by the user */
  businessPurpose?: Maybe<Scalars['String']['output']>;
  businessTradingName?: Maybe<Scalars['String']['output']>;
  cardHolderRepresentation?: Maybe<Scalars['String']['output']>;
  /** Suggested card holder representations for user */
  cardHolderRepresentations: Array<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  /** The details of an existing OAuth2 client */
  client?: Maybe<Client>;
  /** The list of all OAuth2 clients for the current user */
  clients: Array<Client>;
  companyType?: Maybe<CompanyType>;
  country?: Maybe<Scalars['String']['output']>;
  /** Coupon code assigned to the user that can be redeemed during subscription update */
  couponCodeOffer?: Maybe<Scalars['String']['output']>;
  /** @deprecated This field will be removed in an upcoming release */
  createdAt: Scalars['DateTime']['output'];
  /** The user's Solaris customer vetting status */
  customerVettingStatus?: Maybe<CustomerVettingStatus>;
  /** User's documents */
  documentCategories: Array<DocumentCategory>;
  /** User's documents */
  documents: Array<Document>;
  /** Retrieves draft of seizure payment order */
  draftSeizurePaymentOrder: Scalars['String']['output'];
  email: Scalars['String']['output'];
  emailDocument: EmailDocument;
  emailDocuments: Array<EmailDocument>;
  euerDeclaration?: Maybe<TaxDeclaration>;
  expectedMonthlyRevenueCents?: Maybe<Scalars['Float']['output']>;
  /** Active user features */
  features: Array<Scalars['String']['output']>;
  fibuFinalCheckTasks?: Maybe<Array<FibuFinalCheckTask>>;
  firstName?: Maybe<Scalars['String']['output']>;
  gender?: Maybe<Gender>;
  hasBusinessTaxNumber?: Maybe<Scalars['Boolean']['output']>;
  hasBusinessTaxNumberUpdatedAt?: Maybe<Scalars['DateTime']['output']>;
  hasPersonalTaxNumber?: Maybe<Scalars['Boolean']['output']>;
  hasPersonalTaxNumberUpdatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** IDNow identification details for user */
  identification: IdentificationDetails;
  /**
   * The link to use for IDNow identification
   * @deprecated This field will be removed in an upcoming release and should now be queried from "viewer.identification.link"
   */
  identificationLink?: Maybe<Scalars['String']['output']>;
  /**
   * The user's IDNow identification status
   * @deprecated This field will be removed in an upcoming release and should now be queried from "viewer.identification.status"
   */
  identificationStatus?: Maybe<IdentificationStatus>;
  incomeTaxDeclaration?: Maybe<TaxDeclaration>;
  /** Bookkeeping partners information for user */
  integrations: Array<UserIntegration>;
  invoice?: Maybe<Invoice>;
  invoiceAsset: Scalars['String']['output'];
  /** The list of all customers of the current user */
  invoiceCustomers?: Maybe<Array<InvoiceCustomerOutput>>;
  invoicePdf: Scalars['String']['output'];
  invoiceSettings?: Maybe<InvoiceSettingsOutput>;
  invoices: InvoicingDashboardData;
  /** Indicates whether the user pays taxes in the US */
  isUSPerson?: Maybe<Scalars['Boolean']['output']>;
  language?: Maybe<Scalars['String']['output']>;
  /** User's last business address before a specific date */
  lastBusinessAddress: BusinessAddress;
  lastName?: Maybe<Scalars['String']['output']>;
  mainAccount?: Maybe<Account>;
  /** User metadata. These fields are likely to get frequently updated or changed. */
  metadata: UserMetadata;
  missingBusinessTaxNumberNote?: Maybe<Scalars['String']['output']>;
  missingPersonalTaxNumberNote?: Maybe<Scalars['String']['output']>;
  mobileNumber?: Maybe<Scalars['String']['output']>;
  naceCodeId?: Maybe<Scalars['Float']['output']>;
  nationality?: Maybe<Nationality>;
  /** All push-notification types and their state */
  notifications: Array<Notification>;
  poaExportedAt?: Maybe<Scalars['DateTime']['output']>;
  poaSignedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Retrieves signed POA PDF for user. */
  poaUrl?: Maybe<Scalars['String']['output']>;
  postCode?: Maybe<Scalars['String']['output']>;
  /** Premium subscription discount for user */
  premiumSubscriptionDiscount: Discount;
  publicId: Scalars['ID']['output'];
  questionnaire?: Maybe<Questionnaire>;
  questionnaireTasks: Array<QuestionnaireTask>;
  questionnaires?: Maybe<Array<Questionnaire>>;
  receiptMatchingIntroDismissedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The user's associated Recurly Account */
  recurlyAccount?: Maybe<RecurlyAccount>;
  recurlyInvoices: Array<RecurlyInvoice>;
  /** Referral details for user */
  referral: ReferralDetails;
  /**
   * The user's referral code to use for promotional purposes
   * @deprecated This field will be removed in an upcoming release and should now be queried from "viewer.referral.code"
   */
  referralCode?: Maybe<Scalars['String']['output']>;
  /** The user's Solaris risk clarification status */
  riskClassificationStatus?: Maybe<RiskClassificationStatus>;
  /** The user's Solaris screening progress */
  screeningProgress?: Maybe<ScreeningProgress>;
  /** Show question set */
  showQuestionSet?: Maybe<QuestionSet>;
  street?: Maybe<Scalars['String']['output']>;
  /** The available subscription plans */
  subscriptionPlans: SubscriptionPlansResponse;
  /** The plans a user has subscribed to */
  subscriptions: Array<UserSubscription>;
  taxCase?: Maybe<TaxCase>;
  /** Tax details for user */
  taxDetails: UserTaxDetails;
  /** User's tax numbers */
  taxNumbers: Array<TaxNumber>;
  /** @deprecated This field will be removed in an upcoming release and should now be queried from "viewer.taxDetails.taxPaymentFrequency" */
  taxPaymentFrequency?: Maybe<TaxPaymentFrequency>;
  /** @deprecated This field will be removed in an upcoming release and should now be queried from "viewer.taxDetails.taxRate" */
  taxRate?: Maybe<Scalars['Int']['output']>;
  taxServiceOnboardingCompletedAt?: Maybe<Scalars['DateTime']['output']>;
  tradeTaxDeclaration?: Maybe<TaxDeclaration>;
  unfinishedTransfers: Array<UnfinishedTransfer>;
  untrustedPhoneNumber?: Maybe<Scalars['String']['output']>;
  /** User's tours */
  userTours: Array<UserTour>;
  vatAnnualDeclaration?: Maybe<TaxDeclaration>;
  vatDeclarationBannerDismissedAt?: Maybe<Scalars['DateTime']['output']>;
  /** @deprecated This field will be removed in an upcoming release and should now be queried from "viewer.taxDetails.vatNumber" */
  vatNumber?: Maybe<Scalars['String']['output']>;
  /** @deprecated This field will be removed in an upcoming release and should now be queried from "viewer.taxDetails.vatPaymentFrequency" */
  vatPaymentFrequency?: Maybe<PaymentFrequency>;
  /** @deprecated This field will be removed in an upcoming release and should now be queried from "viewer.taxDetails.vatRate" */
  vatRate?: Maybe<UserVatRate>;
  websiteSocialMedia?: Maybe<Scalars['String']['output']>;
  workAsHandyman?: Maybe<Scalars['Boolean']['output']>;
};


export type UserAvailablePlansArgs = {
  couponCode?: InputMaybe<Scalars['String']['input']>;
};


export type UserBannersArgs = {
  isWebapp?: InputMaybe<Scalars['Boolean']['input']>;
};


export type UserBizTaxBookkeepingConfirmationArgs = {
  year: Scalars['Int']['input'];
};


export type UserBizTaxDeclarationChecksArgs = {
  year: Scalars['Int']['input'];
};


export type UserBizTaxDeclarationSettingArgs = {
  year: Scalars['Int']['input'];
};


export type UserBizTaxDeclarationSubmissionsArgs = {
  year: Scalars['Int']['input'];
};


export type UserBizTaxQuestionnairesEuerArgs = {
  year: Scalars['Int']['input'];
};


export type UserBusinessAssetArgs = {
  businessAssetId: Scalars['ID']['input'];
};


export type UserClientArgs = {
  id: Scalars['String']['input'];
};


export type UserDocumentCategoriesArgs = {
  categoryNames?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type UserDocumentsArgs = {
  categoryIds?: InputMaybe<Array<Scalars['String']['input']>>;
  year?: InputMaybe<Scalars['Int']['input']>;
};


export type UserDraftSeizurePaymentOrderArgs = {
  seizureId: Scalars['ID']['input'];
};


export type UserEmailDocumentArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};


export type UserEmailDocumentsArgs = {
  filterByUnmatched?: InputMaybe<Scalars['Boolean']['input']>;
  uploadSources?: InputMaybe<Array<DocumentUploadSource>>;
};


export type UserEuerDeclarationArgs = {
  year: Scalars['Int']['input'];
};


export type UserFibuFinalCheckTasksArgs = {
  year: Scalars['Int']['input'];
};


export type UserIncomeTaxDeclarationArgs = {
  year: Scalars['Int']['input'];
};


export type UserInvoiceArgs = {
  id: Scalars['String']['input'];
};


export type UserInvoiceAssetArgs = {
  invoiceId: Scalars['ID']['input'];
  isBase64: Scalars['Boolean']['input'];
};


export type UserInvoicesArgs = {
  pageNumber: Scalars['Int']['input'];
};


export type UserMetadataArgs = {
  platform?: InputMaybe<Platform>;
};


export type UserPremiumSubscriptionDiscountArgs = {
  couponCode?: InputMaybe<Scalars['String']['input']>;
};


export type UserQuestionnaireArgs = {
  questionnaireId?: InputMaybe<Scalars['ID']['input']>;
  type: QuestionnaireType;
  year: Scalars['Int']['input'];
};


export type UserQuestionnairesArgs = {
  year: Scalars['Int']['input'];
};


export type UserSubscriptionPlansArgs = {
  couponCode?: InputMaybe<Scalars['String']['input']>;
};


export type UserTaxCaseArgs = {
  year: Scalars['Int']['input'];
};


export type UserTradeTaxDeclarationArgs = {
  year: Scalars['Int']['input'];
};


export type UserVatAnnualDeclarationArgs = {
  year: Scalars['Int']['input'];
};

/** Business Address of a User */
export type UserBusinessAddress = {
  __typename?: 'UserBusinessAddress';
  city: Scalars['String']['output'];
  country: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  postCode: Scalars['String']['output'];
  street: Scalars['String']['output'];
};

export enum UserConfirmation {
  AdvisorDocumentsUploaded = 'ADVISOR_DOCUMENTS_UPLOADED',
  ManualDocumentsUploaded = 'MANUAL_DOCUMENTS_UPLOADED',
  SubmitAssets = 'SUBMIT_ASSETS',
  SubmitExternalTransactions = 'SUBMIT_EXTERNAL_TRANSACTIONS',
  TaxDeclarationNotNeeded = 'TAX_DECLARATION_NOT_NEEDED',
  ToolsDocumentsUploaded = 'TOOLS_DOCUMENTS_UPLOADED'
}

export type UserDependent = {
  __typename?: 'UserDependent';
  birthDate: Scalars['DateTime']['output'];
  deTaxId?: Maybe<Scalars['String']['output']>;
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  marriageEndDate?: Maybe<Scalars['DateTime']['output']>;
  marriageStartDate?: Maybe<Scalars['DateTime']['output']>;
  type: UserDependentType;
};

export type UserDependentInput = {
  birthDate: Scalars['String']['input'];
  deTaxId?: InputMaybe<Scalars['String']['input']>;
  firstName: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  lastName: Scalars['String']['input'];
  marriageEndDate?: InputMaybe<Scalars['String']['input']>;
  marriageStartDate?: InputMaybe<Scalars['String']['input']>;
  type: UserDependentType;
};

export enum UserDependentType {
  Child = 'CHILD',
  Partner = 'PARTNER'
}

export type UserExternalTransactionInput = {
  amount: Scalars['Float']['input'];
  businessAsset?: InputMaybe<BusinessAssetInput>;
  businessAssetForm?: InputMaybe<BusinessAssetForm>;
  categoryCode?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  iban?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isCashTransaction?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  paymentDate: Scalars['DateTime']['input'];
  splits?: InputMaybe<Array<TransactionSplitInput>>;
  vatCategoryCode?: InputMaybe<Scalars['String']['input']>;
  vatRate?: InputMaybe<VatRate>;
};

export type UserIntegration = {
  __typename?: 'UserIntegration';
  hasAccount: Scalars['Boolean']['output'];
  isConnected: Scalars['Boolean']['output'];
  type: IntegrationType;
};

export type UserMetadata = {
  __typename?: 'UserMetadata';
  acceptedTermsVersion?: Maybe<Scalars['String']['output']>;
  /** List of months user can request a bank statement for */
  availableStatements?: Maybe<Array<AvailableStatements>>;
  categorizationScreenShown?: Maybe<Scalars['Boolean']['output']>;
  currentTermsAccepted: Scalars['Boolean']['output'];
  currentTermsVersion: Scalars['String']['output'];
  directDebitMandateAccepted: Scalars['Boolean']['output'];
  emailConnections: Array<Scalars['String']['output']>;
  emailFetchSetupUrl?: Maybe<Scalars['String']['output']>;
  intercomDigest?: Maybe<Scalars['String']['output']>;
  /** Is user's Kontist account closed */
  isAccountClosed: Scalars['Boolean']['output'];
  lastTermsVersionAcceptedAt?: Maybe<Scalars['DateTime']['output']>;
  lastTermsVersionRejectedAt?: Maybe<Scalars['DateTime']['output']>;
  lastTermsVersionSkippedAt?: Maybe<Scalars['DateTime']['output']>;
  marketingConsentAccepted: Scalars['Boolean']['output'];
  newTermsDeadlineDate: Scalars['String']['output'];
  phoneNumberVerificationRequired: Scalars['Boolean']['output'];
  signupCompleted: Scalars['Boolean']['output'];
  taxAdvisoryTermsVersionAccepted: Scalars['Boolean']['output'];
  /** Screens and banners seen by user */
  viewLogs?: Maybe<Array<Scalars['String']['output']>>;
};

export type UserOrAuthResponse = AuthorizeThroughDeviceSigningOrMobileNumberResponse | User;

export type UserProductInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  price?: InputMaybe<Scalars['Float']['input']>;
  vat?: InputMaybe<Scalars['String']['input']>;
};

export enum UserReviewStatus {
  Feedback = 'FEEDBACK',
  NegativePending = 'NEGATIVE_PENDING',
  NegativeReminder = 'NEGATIVE_REMINDER',
  PositivePending = 'POSITIVE_PENDING',
  PositiveReminder = 'POSITIVE_REMINDER',
  Reviewed = 'REVIEWED'
}

export type UserSignupData = {
  __typename?: 'UserSignupData';
  address?: Maybe<Address>;
  birthDate?: Maybe<Scalars['DateTime']['output']>;
  birthPlace?: Maybe<Scalars['String']['output']>;
  customerVettingStatus?: Maybe<CustomerVettingStatus>;
  deTaxId?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  gender?: Maybe<Scalars['String']['output']>;
  identificationLink?: Maybe<Scalars['String']['output']>;
  identificationStatus?: Maybe<IdentificationStatus>;
  isUsPerson?: Maybe<Scalars['Boolean']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  mobileNumber?: Maybe<Scalars['String']['output']>;
  nationality?: Maybe<Scalars['String']['output']>;
  riskClassificationStatus?: Maybe<RiskClassificationStatus>;
  screeningProgress?: Maybe<ScreeningProgress>;
  untrustedPhoneNumber?: Maybe<Scalars['String']['output']>;
};

export type UserSubscription = {
  __typename?: 'UserSubscription';
  /** The state of the subscription */
  state: PurchaseState;
  /** The type of the plans a user has subscribed to */
  type: PurchaseType;
};

export type UserTaxDetails = {
  __typename?: 'UserTaxDetails';
  deTaxId?: Maybe<Scalars['String']['output']>;
  dependents?: Maybe<Array<UserDependent>>;
  hasBusinessTaxNumber?: Maybe<Scalars['Boolean']['output']>;
  lastTaxPaymentDate?: Maybe<Scalars['DateTime']['output']>;
  lastVatPaymentDate?: Maybe<Scalars['DateTime']['output']>;
  missingBusinessTaxNumberNote?: Maybe<Scalars['String']['output']>;
  missingPersonalTaxNumberNote?: Maybe<Scalars['String']['output']>;
  needsToProvideTaxIdentification: Scalars['Boolean']['output'];
  permanentExtensionStatus?: Maybe<PermanentExtensionStatus>;
  personalTaxNumber?: Maybe<Scalars['String']['output']>;
  taxNumber?: Maybe<Scalars['String']['output']>;
  /** @deprecated This field will be removed in an upcoming release. Do not rely on it for any new features */
  taxPaymentFrequency?: Maybe<TaxPaymentFrequency>;
  taxRate?: Maybe<Scalars['Int']['output']>;
  vatExemptionWithItd?: Maybe<VatExemptionWithItd>;
  vatExemptionWithoutItd?: Maybe<VatExemptionWithoutItd>;
  vatNumber?: Maybe<Scalars['String']['output']>;
  vatPaymentFrequency?: Maybe<PaymentFrequency>;
  vatRate?: Maybe<UserVatRate>;
};

export type UserTaxDetailsInput = {
  deTaxId?: InputMaybe<Scalars['String']['input']>;
  dependentsTaxIds?: InputMaybe<Array<DependentsTaxIds>>;
  hasBusinessTaxNumber?: InputMaybe<Scalars['Boolean']['input']>;
  hasPersonalTaxNumber?: InputMaybe<Scalars['Boolean']['input']>;
  missingBusinessTaxNumberNote?: InputMaybe<Scalars['String']['input']>;
  missingPersonalTaxNumberNote?: InputMaybe<Scalars['String']['input']>;
  permanentExtensionStatus?: InputMaybe<PermanentExtensionStatus>;
  personalTaxNumber?: InputMaybe<Scalars['String']['input']>;
  taxNumber?: InputMaybe<Scalars['String']['input']>;
  vatExemptionWithItd?: InputMaybe<VatExemptionWithItd>;
  vatExemptionWithoutItd?: InputMaybe<VatExemptionWithoutItd>;
  vatNumber?: InputMaybe<Scalars['String']['input']>;
  vatPaymentFrequency?: InputMaybe<PaymentFrequency>;
};

/** Tours of users */
export type UserTour = {
  __typename?: 'UserTour';
  name: TourName;
  status: TourStatus;
};

export type UserUpdateInput = {
  /** The version of terms user has accepted */
  acceptedTermsVersion?: InputMaybe<Scalars['String']['input']>;
  accountingTool?: InputMaybe<Scalars['String']['input']>;
  birthDate?: InputMaybe<Scalars['DateTime']['input']>;
  birthPlace?: InputMaybe<Scalars['String']['input']>;
  businessPurpose?: InputMaybe<Scalars['String']['input']>;
  businessTradingName?: InputMaybe<Scalars['String']['input']>;
  categorizationScreenShown?: InputMaybe<Scalars['Boolean']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  companyType?: InputMaybe<CompanyType>;
  country?: InputMaybe<Nationality>;
  /** Indicates user has accepted Kontist direct debit mandate */
  directDebitMandateAccepted?: InputMaybe<Scalars['Boolean']['input']>;
  /** Expected monthly revenue in euro cents */
  expectedMonthlyRevenueCents?: InputMaybe<Scalars['Int']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Gender>;
  hasEmployees?: InputMaybe<Scalars['Boolean']['input']>;
  hasMoreThanOneBusiness?: InputMaybe<Scalars['Boolean']['input']>;
  hasSecondBusinessAccount?: InputMaybe<Scalars['Boolean']['input']>;
  idnowReminderTime?: InputMaybe<Scalars['DateTime']['input']>;
  idnowReminderType?: InputMaybe<IdnowReminderType>;
  internationalCustomers?: InputMaybe<InternationalCustomers>;
  /** Indicates whether the user pays taxes in the US */
  isUSPerson?: InputMaybe<Scalars['Boolean']['input']>;
  language?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Indicates user has accepted to receive Kontist marketing communication */
  marketingConsentAccepted?: InputMaybe<Scalars['Boolean']['input']>;
  maximumCashTransactionsPercentage?: InputMaybe<MaximumCashTransactionsPercentage>;
  nationality?: InputMaybe<Nationality>;
  /** Indicates user has confirmed he is acting as a business and not a consumer */
  nonConsumerConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates user has confirmed he is opening their account in their name, for the use of their business */
  ownEconomicInterestConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  permanentExtensionStatus?: InputMaybe<PermanentExtensionStatus>;
  postCode?: InputMaybe<Scalars['String']['input']>;
  profession?: InputMaybe<Scalars['String']['input']>;
  street?: InputMaybe<Scalars['String']['input']>;
  subjectToAccounting?: InputMaybe<ThreeStateAnswer>;
  taxAdvisoryTermsVersionAccepted?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if user started upgrading to Kontax plan */
  taxServiceOnboardingStarted?: InputMaybe<Scalars['Boolean']['input']>;
  /** Sets a mobile number for the user to be verified later */
  untrustedPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  vatNumber?: InputMaybe<Scalars['String']['input']>;
  vatPaymentFrequency?: InputMaybe<PaymentFrequency>;
  vatRate?: InputMaybe<Scalars['Int']['input']>;
  /** The website or social media url of the user */
  websiteSocialMedia?: InputMaybe<Scalars['String']['input']>;
  workAsHandyman?: InputMaybe<Scalars['Boolean']['input']>;
  workingInEcommerce?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum UserVatRate {
  Vat_0 = 'VAT_0',
  Vat_19 = 'VAT_19'
}

export enum VatCategoryCode {
  Dit_5 = 'DIT_5',
  Dit_7 = 'DIT_7',
  Dit_16 = 'DIT_16',
  Dit_19 = 'DIT_19',
  ExportDelivery = 'EXPORT_DELIVERY',
  Income_0 = 'INCOME_0',
  Income_0Itd = 'INCOME_0_ITD',
  Income_5 = 'INCOME_5',
  Income_7 = 'INCOME_7',
  Income_13B5Ustg = 'INCOME_13B5_USTG',
  Income_16 = 'INCOME_16',
  Income_19 = 'INCOME_19',
  IncomeEuB2B = 'INCOME_EU_B2B',
  IncomeEuB2C_5 = 'INCOME_EU_B2C_5',
  IncomeEuB2C_7 = 'INCOME_EU_B2C_7',
  IncomeEuB2C_16 = 'INCOME_EU_B2C_16',
  IncomeEuB2C_19 = 'INCOME_EU_B2C_19',
  IncomeEuIntraB2B = 'INCOME_EU_INTRA_B2B',
  IncomeEuIntraB2C_5 = 'INCOME_EU_INTRA_B2C_5',
  IncomeEuIntraB2C_7 = 'INCOME_EU_INTRA_B2C_7',
  IncomeEuIntraB2C_16 = 'INCOME_EU_INTRA_B2C_16',
  IncomeEuIntraB2C_19 = 'INCOME_EU_INTRA_B2C_19',
  IntraAcquisitionIt = 'INTRA_ACQUISITION_IT',
  NonTaxable = 'NON_TAXABLE',
  NoItd = 'NO_ITD',
  NoVat = 'NO_VAT',
  ReverseCharge = 'REVERSE_CHARGE',
  ReverseChargeIt = 'REVERSE_CHARGE_IT'
}

export enum VatExemptionWithItd {
  Section_4Nr_7 = 'SECTION_4_NR_7'
}

export enum VatExemptionWithoutItd {
  Section_4Nr_8 = 'SECTION_4_NR_8',
  Section_4Nr_11 = 'SECTION_4_NR_11',
  Section_4Nr_14 = 'SECTION_4_NR_14',
  Section_4Nr_16 = 'SECTION_4_NR_16',
  Section_4Nr_20 = 'SECTION_4_NR_20',
  Section_4Nr_21 = 'SECTION_4_NR_21',
  Section_4Nr_22 = 'SECTION_4_NR_22'
}

export enum VatRate {
  ReverseCharge = 'REVERSE_CHARGE',
  Vat_0 = 'VAT_0',
  Vat_5 = 'VAT_5',
  Vat_7 = 'VAT_7',
  Vat_16 = 'VAT_16',
  Vat_19 = 'VAT_19'
}

/** An account's VAT settings specific to a year */
export type VatYearSetting = {
  __typename?: 'VatYearSetting';
  vatPaymentFrequency: Scalars['String']['output'];
  year: Scalars['Float']['output'];
};

export type VirtualCardDetailsArgs = {
  deviceId: Scalars['String']['input'];
  jwe: Jwe;
  jwk: Jwk;
  signature: Scalars['String']['input'];
};

export type WhitelistCardResponse = {
  __typename?: 'WhitelistCardResponse';
  id: Scalars['String']['output'];
  resolution: CaseResolution;
  whitelistedUntil: Scalars['String']['output'];
};
